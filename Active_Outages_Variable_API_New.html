<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Active Outages</title>
    <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            overflow-x: hidden;
        }

        /* Modern animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 119, 198, 0.2) 0%, transparent 50%);
            animation: float 20s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            33% { transform: translateY(-30px) rotate(2deg); }
            66% { transform: translateY(-20px) rotate(-2deg); }
        }

        .container {
            max-width: 98vw;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.37),
                0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            overflow: hidden;
            position: relative;
            animation: slideInUp 0.8s ease-out;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            color: white;
            padding: 40px 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255,255,255,0.1) 0%, transparent 100%);
            pointer-events: none;
        }

        .header h1 {
            font-size: clamp(2rem, 5vw, 3.5rem);
            margin-bottom: 15px;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            font-weight: 700;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
            background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.2em;
            font-weight: 300;
            position: relative;
            z-index: 1;
            margin: 0;
        }

        .toolbar {
            background: rgba(248, 249, 250, 0.8);
            backdrop-filter: blur(10px);
            padding: 24px 32px;
            border-bottom: 1px solid rgba(233, 236, 239, 0.5);
            display: flex;
            flex-wrap: wrap;
            gap: 24px;
            align-items: center;
            position: relative;
            overflow: visible;
            z-index: 10;
        }

        .toolbar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
        }

        .toolbar-group {
            display: flex;
            gap: 12px;
            align-items: center;
            border-right: 1px solid rgba(222, 226, 230, 0.6);
            padding-right: 20px;
            margin-right: 16px;
            position: relative;
            z-index: 1;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 16px 28px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 
                0 4px 20px rgba(102, 126, 234, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: fit-content;
            white-space: nowrap;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 8px 30px rgba(102, 126, 234, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.2) inset;
        }

        .btn:active {
            transform: translateY(-1px) scale(0.98);
            transition: all 0.1s ease;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #8b949e 0%, #6c757d 100%);
            box-shadow: 
                0 4px 20px rgba(108, 117, 125, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
        }

        .btn-secondary:hover {
            box-shadow: 
                0 8px 30px rgba(108, 117, 125, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.2) inset;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            box-shadow: 
                0 4px 20px rgba(240, 147, 251, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
        }

        .btn-warning:hover {
            box-shadow: 
                0 8px 30px rgba(240, 147, 251, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.2) inset;
        }

        .btn-info {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 
                0 4px 20px rgba(79, 172, 254, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
        }

        .btn-info:hover {
            box-shadow: 
                0 8px 30px rgba(79, 172, 254, 0.5),
                0 0 0 1px rgba(255, 255, 255, 0.2) inset;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status-bar {
            flex: 1;
            text-align: right;
            color: #6c757d;
            font-weight: 500;
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            margin-left: 16px;
        }

        .status-bar:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .progress-container {
            padding: 0 20px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #357abd);
            width: 0%;
            transition: width 0.3s ease;
            animation: loading 2s infinite;
        }

        @keyframes loading {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(0%); }
            100% { transform: translateX(100%); }
        }

        .tabs-container {
            background: white;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            position: relative;
            z-index: 1;
        }

        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            overflow-x: auto;
        }

        .tab {
            padding: 16px 32px;
            background: transparent;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 12px;
            white-space: nowrap;
            position: relative;
            font-size: 15px;
        }

        .tab.active {
            color: #667eea;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            box-shadow: 
                0 4px 20px rgba(102, 126, 234, 0.2),
                0 0 0 1px rgba(255, 255, 255, 0.3) inset;
            transform: translateY(-2px);
        }

        .tab:hover {
            color: #667eea;
            background: rgba(102, 126, 234, 0.08);
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
            padding: 10px;
            height: 60vh;
            overflow: auto;
            width: 100%;
            box-sizing: border-box;
        }

        .tab-content.active {
            display: block;
        }

        .table-container {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            overflow: auto;
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.2),
                0 0 0 1px rgba(255, 255, 255, 0.3) inset;
            width: 100%;
            max-height: 55vh;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            z-index: 1;
            display: block;
        }

        /* Custom scrollbar styling for table container */
        .table-container::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .table-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 6px;
        }

        .table-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px;
            border: 2px solid #f1f1f1;
        }

        .table-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #764ba2 0%, #f093fb 100%);
        }

        .table-container::-webkit-scrollbar-corner {
            background: #f1f1f1;
        }

        /* Firefox scrollbar styling */
        .table-container {
            scrollbar-width: auto;
            scrollbar-color: #667eea #f1f1f1;
        }

        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 14px;
            table-layout: fixed; /* Fixed layout for better column control */
            max-width: 100%;
            min-width: 100%;
        }

        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 8px;
            text-align: center;
            font-weight: 700;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
            position: sticky;
            top: 0;
            z-index: 10;
            overflow: hidden;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
            hyphens: auto;
            position: relative; /* For resize handle */
            font-size: 14px;
            letter-spacing: 0.5px;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            line-height: 1.3;
            min-height: 40px;
            vertical-align: middle;
        }

        th.resizing {
            cursor: col-resize;
            user-select: none;
        }

        th .resize-handle {
            position: absolute;
            top: 0;
            right: 0;
            width: 8px;
            height: 100%;
            cursor: col-resize;
            z-index: 1;
            background: transparent;
            border-right: 2px solid transparent;
        }

        th .resize-handle:hover,
        th .resize-handle.active {
            background-color: rgba(255, 255, 255, 0.4);
            border-right: 2px solid rgba(255, 255, 255, 0.8);
        }

        th .header-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 6px;
            cursor: row-resize;
            z-index: 1;
            background: transparent;
            border-bottom: 2px solid transparent;
        }

        th .header-resize-handle:hover,
        th .header-resize-handle.active {
            background-color: rgba(255, 255, 255, 0.4);
            border-bottom: 2px solid rgba(255, 255, 255, 0.8);
        }

        td {
            padding: 6px 4px;
            border-bottom: 1px solid #e9ecef;
            border-right: 1px solid #e9ecef;
            overflow: hidden;
            position: relative; /* For row resize */
            font-size: 13px;
            text-align: center;
            vertical-align: middle;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
            hyphens: auto;
            line-height: 1.2;
            height: 100%;
            display: table-cell;
        }

        /* Special styling for EM Field Feedback column */
        td.em-field-feedback {
            text-align: left !important;
        }

        tr {
            position: relative; /* For row resize */
            height: 25px; /* More compact default height */
        }

        tr .row-resize-handle {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 6px;
            width: 100%;
            cursor: row-resize;
            z-index: 1;
            background: transparent;
            border-bottom: 2px solid transparent;
        }

        tr .row-resize-handle:hover,
        tr .row-resize-handle.active {
            background-color: rgba(102, 126, 234, 0.3);
            border-bottom: 2px solid rgba(102, 126, 234, 0.6);
        }

        tr.resizing {
            cursor: row-resize;
            user-select: none;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: rgba(102, 126, 234, 0.12);
        }

        .editable {
            border: none;
            background: transparent;
            width: 100%;
            height: 100%;
            padding: 8px 4px;
            font-size: 14px;
            text-align: center;
            resize: none;
            line-height: 1.4;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
            overflow-wrap: break-word;
            box-sizing: border-box;
            vertical-align: middle;
        }

        .editable:focus {
            outline: 2px solid #667eea;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.2);
            transform: scale(1.02);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Special styling for EM Field Feedback column */
        td.em-field-feedback {
            text-align: left !important;
            word-wrap: break-word !important;
            word-break: break-word !important;
            white-space: normal !important;
        }

        th.em-field-feedback {
            text-align: center !important;
        }

        .em-field-feedback .editable {
            text-align: left !important;
            word-wrap: break-word !important;
            word-break: break-word !important;
            white-space: normal !important;
            overflow-wrap: break-word !important;
            padding-left: 8px !important;
        }

        /* Custom scrollbar for edit boxes - Cross-browser */
        .editable::-webkit-scrollbar {
            width: 6px;
        }

        .editable::-webkit-scrollbar-track {
            background: transparent;
        }

        .editable::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .editable::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.4);
        }

        /* Firefox scrollbar styling */
        .editable {
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
        }

        /* Table styling controls */
        .style-control {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            color: #6c757d;
            position: relative;
            z-index: 2;
        }

        /* Dropdown menu styling */
        .dropdown-menu {
            display: none;
            position: absolute !important;
            top: calc(100% + 8px) !important;
            left: 0 !important;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            padding: 20px;
            min-width: 220px;
            z-index: 9999 !important;
            animation: dropdownSlideIn 0.3s ease-out;
            pointer-events: auto !important;
            transform: translateZ(0) !important;
            will-change: transform !important;
        }

        @keyframes dropdownSlideIn {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.95) translateZ(0);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1) translateZ(0);
            }
        }

        .dropdown-menu.show {
            display: block !important;
            transform: translateZ(0) !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        .dropdown-section {
            margin-bottom: 20px;
        }

        .dropdown-section:last-child {
            margin-bottom: 0;
        }

        .dropdown-section label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 12px;
        }

        .dropdown-section select,
        .dropdown-section input[type="color"] {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
        }

        .dropdown-section input[type="color"] {
            height: 35px;
            padding: 2px;
            cursor: pointer;
        }

        .style-control label {
            font-weight: 600;
            min-width: 90px;
        }

        .style-control input[type="range"] {
            width: 80px;
        }

        .style-control input[type="color"] {
            width: 30px;
            height: 25px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .style-control select {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Center aligned tabs - Modern Style */
        .tabs {
            display: flex;
            background: rgba(248, 249, 250, 0.6);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(222, 226, 230, 0.5);
            overflow-x: auto;
            justify-content: center;
            padding: 8px 20px;
            gap: 8px;
        }

        .hub-site-field {
            font-weight: 600 !important;
            text-transform: uppercase !important;
            color: #2c3e50 !important;
        }

        .hub-site-field:focus {
            outline: 2px solid #f39c12 !important;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.4);
        }

        .hub-site-field::placeholder {
            color: #8b7355 !important;
            font-weight: normal !important;
            text-transform: none !important;
        }

        .auto-filled {
            transition: all 0.3s ease;
        }



        .date-time-field:focus {
            outline: 2px solid #ff9800 !important;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.3);
        }

        .date-time-field::placeholder {
            color: #bf6900 !important;
            font-style: italic;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal.show .modal-content {
            transform: scale(1);
        }

        .modal h3 {
            color: #4a90e2;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .modal p {
            color: #6c757d;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .loading-spinner {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
        }

        .spinner {
            width: 50px;
            height: 50px;
            position: relative;
            border-radius: 50%;
            background: conic-gradient(from 0deg, #667eea, #764ba2, #f093fb, #667eea);
            animation: spin 1.5s linear infinite;
        }

        .spinner::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            bottom: 8px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            backdrop-filter: blur(10px);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                border-radius: 20px;
            }

            .header {
                padding: 30px 15px;
            }

            .toolbar {
                flex-direction: column;
                align-items: stretch;
                padding: 20px;
                gap: 16px;
            }

            .toolbar-group {
                border-right: none;
                border-bottom: 1px solid rgba(222, 226, 230, 0.5);
                padding-bottom: 16px;
                margin-bottom: 12px;
                gap: 8px;
            }

            .toolbar-group:last-child {
                border-bottom: none;
                margin-bottom: 0;
                padding-bottom: 0;
            }

            .tabs {
                padding: 8px 12px;
                gap: 6px;
            }

            .tab {
                padding: 12px 20px;
                font-size: 14px;
            }

            .tab-content {
                height: 50vh;
                padding: 8px;
            }

            .table-container {
                border-radius: 12px;
            }

            table {
                font-size: 12px;
            }

            th, td {
                padding: 8px 4px;
            }

            .btn {
                padding: 14px 22px;
                font-size: 13px;
                gap: 10px;
            }

            .toast-container {
                max-width: calc(100vw - 20px);
                right: 10px;
                left: 10px;
            }
        }

        /* Enhanced glassmorphism effects */
        .progress-bar {
            background: rgba(233, 236, 239, 0.3);
            backdrop-filter: blur(10px);
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2, #f093fb);
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 2000;
            max-width: 400px;
        }

        .toast {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.2) inset;
            margin-bottom: 12px;
            padding: 20px 24px;
            border-left: 4px solid #667eea;
            transform: translateX(450px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            opacity: 0;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            border-left-color: #28a745;
            background: linear-gradient(135deg, #f8fff9 0%, #e8f5e8 100%);
        }

        .toast.error {
            border-left-color: #dc3545;
            background: linear-gradient(135deg, #fff8f8 0%, #ffe6e6 100%);
        }

        .toast.warning {
            border-left-color: #ffc107;
            background: linear-gradient(135deg, #fffef8 0%, #fff3cd 100%);
        }

        .toast.info {
            border-left-color: #17a2b8;
            background: linear-gradient(135deg, #f8fdff 0%, #e1f5fe 100%);
        }

        .toast-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .toast-title {
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toast-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #6c757d;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .toast-close:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #2c3e50;
        }

        .toast-message {
            color: #4a5568;
            line-height: 1.5;
            font-size: 14px;
        }

        .toast-progress {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 3px;
            background: rgba(74, 144, 226, 0.3);
            border-radius: 0 0 12px 12px;
            overflow: hidden;
        }

        .toast-progress-bar {
            height: 100%;
            background: #4a90e2;
            width: 100%;
            transform-origin: left;
            animation: shrink 5s linear forwards;
        }

        @keyframes shrink {
            from { transform: scaleX(1); }
            to { transform: scaleX(0); }
        }

        /* Optimized input styling */
        .editable {
            border: none;
            background: transparent;
            width: 100%;
            padding: 4px;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .editable:focus {
            outline: 2px solid #667eea;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.2);
            transform: scale(1.02);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Fault Level container */
        .fault-level-container {
            position: relative;
            width: 100%;
            z-index: 1;
        }

        /* Fault Level input styling - matches normal table cells */
        .fault-level-input {
            border: none;
            background: transparent;
            width: 100%;
            padding: 4px;
            font-size: 14px;
            text-align: center;
            transition: all 0.2s ease;
            cursor: pointer;
            font-weight: 600;
            letter-spacing: 0.5px;
            word-wrap: break-word;
            word-break: break-word;
            white-space: normal;
            overflow-wrap: break-word;
            min-height: 20px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fault-level-input:focus {
            outline: 2px solid #667eea;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.2);
            transform: scale(1.02);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Custom dropdown for fault levels */
        .fault-level-dropdown {
            position: fixed;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.1) inset;
            z-index: 10000 !important;
            display: none;
            max-height: 220px;
            overflow-y: auto;
            min-width: 160px;
            animation: dropdownSlideIn 0.3s ease-out;
        }

        .fault-level-dropdown.show {
            display: block;
        }

        .fault-level-option {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid rgba(222, 226, 230, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            font-weight: 600;
            letter-spacing: 0.5px;
            border-radius: 8px;
            margin: 4px 8px;
            position: relative;
            overflow: hidden;
        }

        .fault-level-option:last-child {
            border-bottom: none;
            margin-bottom: 8px;
        }

        .fault-level-option:first-child {
            margin-top: 8px;
        }

        .fault-level-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .fault-level-option:hover::before {
            left: 100%;
        }

        .fault-level-option:hover {
            background: rgba(102, 126, 234, 0.12);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .fault-level-option.emergency {
            color: #c62828;
            font-weight: bold;
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            border-left: 4px solid #c62828;
        }

        .fault-level-option.emergency:hover {
            background: linear-gradient(135deg, #ffe8e8 0%, #ffb3ba 100%);
            color: #b71c1c;
            box-shadow: 0 4px 20px rgba(198, 40, 40, 0.3);
        }

        .fault-level-option.critical {
            color: #ef6c00;
            font-weight: bold;
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border-left: 4px solid #ef6c00;
        }

        .fault-level-option.critical:hover {
            background: linear-gradient(135deg, #fff0e6 0%, #ffd699 100%);
            color: #e65100;
            box-shadow: 0 4px 20px rgba(239, 108, 0, 0.3);
        }

        .fault-level-option.major {
            color: #f57f17;
            font-weight: 600;
            background: linear-gradient(135deg, #fffde7 0%, #fff9c4 100%);
            border-left: 4px solid #f57f17;
        }

        .fault-level-option.major:hover {
            background: linear-gradient(135deg, #fffbf0 0%, #fff59d 100%);
            color: #f57c00;
            box-shadow: 0 4px 20px rgba(245, 127, 23, 0.3);
        }

        .fault-level-option.minor {
            color: #7b1fa2;
            font-weight: 500;
            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
            border-left: 4px solid #7b1fa2;
        }

        .fault-level-option.minor:hover {
            background: linear-gradient(135deg, #f0e6f7 0%, #dda0dd 100%);
            color: #6a1b9a;
            box-shadow: 0 4px 20px rgba(123, 31, 162, 0.3);
        }

        /* Custom scrollbar for fault level dropdown */
        .fault-level-dropdown::-webkit-scrollbar {
            width: 8px;
        }

        .fault-level-dropdown::-webkit-scrollbar-track {
            background: rgba(241, 241, 241, 0.3);
            border-radius: 4px;
        }

        .fault-level-dropdown::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .fault-level-dropdown::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #764ba2 0%, #f093fb 100%);
        }

        .editing {
            background: rgba(102, 126, 234, 0.08) !important;
        }

        /* Ensure table fills full width and columns distribute evenly */
        table th,
        table td {
            width: calc(100% / 12); /* All 12 columns share width equally */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Active Outages</h1>
        </div>

        <div class="toolbar">
            <div class="toolbar-group">
                <button class="btn" id="downloadBtn">
                    🔄 Refresh
                </button>
                <button class="btn btn-secondary" id="saveBtn">
                    💾 Save
                </button>
                <button class="btn btn-info" id="exportBtn">
                    📋 Export
                </button>
            </div>
            
            <div class="toolbar-group">
                <div class="style-control">
                    <button class="btn btn-warning" id="databaseBtn">
                        🗃️ Data Base
                    </button>
                    <div class="dropdown-menu" id="databaseDropdown">
                        <div class="dropdown-section">
                            <button class="btn btn-info" id="refreshTokenBtn" style="width: 100%; margin-bottom: 8px;">
                                🔑 Refresh Token
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-info" id="refreshLookupBtn" style="width: 100%; margin-bottom: 8px;">
                                🔄 Refresh DB
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-warning" id="autoFillBtn" style="width: 100%; margin-bottom: 8px;">
                                ⚡ Auto Fill
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-info" id="collaborationSettingsBtn" style="width: 100%;">
                                👥 Live Collaboration
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="toolbar-group">
                <div class="style-control">
                    <button class="btn btn-secondary" id="editRowBtn">
                        📝 Edit Row
                    </button>
                    <div class="dropdown-menu" id="editRowDropdown">
                        <div class="dropdown-section">
                            <button class="btn btn-secondary" id="addRowBtn" style="width: 100%; margin-bottom: 8px;">
                                ➕ Add Row
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-secondary" id="deleteRowBtn" style="width: 100%;">
                                ➖ Delete Row
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="toolbar-group">
                <div class="style-control">
                    <button class="btn btn-info" id="formatBtn">
                        ⚙️ Format
                    </button>
                    <div class="dropdown-menu" id="formatDropdown">
                        <div class="dropdown-section">
                            <button class="btn btn-secondary" id="autoFitWidthBtn" style="width: 100%; margin-bottom: 8px;">
                                📏 Auto-Fit Width
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-secondary" id="autoFitHeightBtn" style="width: 100%; margin-bottom: 8px;">
                                📐 Auto-Fit Height
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-info" id="saveFormatBtn" style="width: 100%; margin-bottom: 8px;">
                                💾 Save Format
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-warning" id="resetDefaultBtn" style="width: 100%; margin-bottom: 8px;">
                                🔄 Reset Default
                            </button>
                        </div>
                        <div class="dropdown-section">
                            <button class="btn btn-info" id="autoRefreshSettingsBtn" style="width: 100%;">
                                ⏱️ Auto-Refresh Settings
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="toolbar-group">
                <div class="style-control">
                    <button class="btn btn-secondary" id="tableStyleBtn">
                        🎨 Table Style
                    </button>
                    <div class="dropdown-menu" id="tableStyleDropdown">
                        <div class="dropdown-section">
                            <label>Table Text Size:</label>
                            <select id="textSizeSelect">
                                <option value="10px">10px</option>
                                <option value="12px">12px</option>
                                <option value="14px" selected>14px</option>
                                <option value="16px">16px</option>
                                <option value="18px">18px</option>
                                <option value="20px">20px</option>
                            </select>
                        </div>
                        <div class="dropdown-section">
                            <label>Header Text Size:</label>
                            <select id="headerSizeSelect">
                                <option value="10px">10px</option>
                                <option value="11px">11px</option>
                                <option value="12px">12px</option>
                                <option value="13px" selected>13px</option>
                                <option value="14px">14px</option>
                                <option value="15px">15px</option>
                                <option value="16px">16px</option>
                            </select>
                        </div>
                        <div class="dropdown-section">
                            <label>Table Text Color:</label>
                            <input type="color" id="textColorPicker" value="#000000">
                        </div>
                        <div class="dropdown-section">
                            <label>Header Text Color:</label>
                            <input type="color" id="headerTextColorPicker" value="#ffffff">
                        </div>
                        <div class="dropdown-section">
                            <label>Header Background:</label>
                            <input type="color" id="headerColorPicker" value="#4a90e2">
                        </div>
                        <div class="dropdown-section">
                            <label>Table Background:</label>
                            <input type="color" id="tableColorPicker" value="#ffffff">
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="status-bar">
                <span id="statusText">Ready</span>
                <div id="liveUpdateIndicator" style="margin-left: 10px; color: #28a745; display: none;">
                    🔴 Live Updates Active
                </div>
                <div id="collaborationIndicator" style="margin-left: 15px; color: #17a2b8; display: none;">
                    <span id="collaborationIcon">👥</span>
                    <span id="collaborationText">Live Sync</span>
                </div>
            </div>
        </div>

        <div class="progress-container">
            <div class="progress-bar" id="progressBar">
                <div class="progress-fill"></div>
            </div>
        </div>

        <div class="tabs-container">
            <div class="tabs" id="tabsHeader"></div>
            <div id="tabsContent"></div>
        </div>
    </div>

    <!-- Toast Notification Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Loading Spinner -->
    <div class="loading-spinner" id="loadingSpinner">
        <div class="spinner"></div>
    </div>

    <script>
        // Configuration with multiple download sources
        const CONFIG = {
            // Dynamic token loading from GitLab JSON with XOR encoding
            tokenApiUrl: "https://gitlab.com/shabakkat/shabakkat-project/-/raw/main/GitHub_API.json",
            encodingKey: "SecureKey2024!@#",
            githubToken: null, // Will be loaded dynamically
            // Fallback encoded token (XOR encoded) - only used if remote loading fails
            fallbackToken: "NA0TKgQfByYvAXRld0MRWSdcUhIxCDgjMgZGBVpMCWUfElMzJBwyDg==",
            repoOwner: "tarek-mahran",
            repoName: "shabakkat",
            filePath: "Active_Outages.xlsx",
            // Auto-refresh delays after save (in milliseconds)
            autoRefreshDelay: 3000, // Initial delay before starting refresh attempts
            autoRefreshRetryDelay: 2000, // Delay between retry attempts
            autoRefreshMaxAttempts: 3, // Maximum number of refresh attempts
            // Live collaboration settings
            liveCollaboration: {
                enabled: true, // Enable real-time collaboration
                pollInterval: 10000, // Check for changes every 10 seconds
                fastPollInterval: 3000, // Faster polling when activity detected
                pauseDuringEdit: true, // Pause polling when user is actively editing
                autoMerge: false, // Automatically merge non-conflicting changes
                showChangeNotifications: true // Show notifications when changes detected
            },
            // Multiple download sources for main file (try in order)
            downloadSources: [
                {
                    name: "Source 1",
                    url: "https://tarek-mahran.github.io/shabakkat/Active_Outages.xlsx",
                    method: "direct"
                },
                {
                    name: "Source 2",
                    url: "https://api.github.com/repos/tarek-mahran/shabakkat/contents/Active_Outages.xlsx",
                    method: "api"
                },
                {
                    name: "Source 3",
                    url: "https://cors-anywhere.herokuapp.com/https://raw.githubusercontent.com/tarek-mahran/shabakkat/refs/heads/main/Active_Outages.xlsx",
                    method: "proxy"
                }
            ],
            // Multiple lookup sources for Zain & LATIS database (try in order)
            lookupSources: [
                {
                    name: "Source 1",
                    url: "https://cors-anywhere.herokuapp.com/https://raw.githubusercontent.com/tarek-mahran/shabakkat/refs/heads/main/Zain%20%26%20LATIS%20Data%20Base.xlsx",
                    method: "proxy"
                },
                {
                    name: "Source 2",
                    url: "https://tarek-mahran.github.io/shabakkat/Zain%20%26%20LATIS%20Data%20Base.xlsx",
                    method: "direct"
                },
                {
                    name: "Source 3",
                    url: "https://api.github.com/repos/tarek-mahran/shabakkat/contents/Zain%20%26%20LATIS%20Data%20Base.xlsx",
                    method: "api"
                }
            ]
        };



        // XOR Encoding/Decoding Functions
        function xorEncode(token, key) {
            let result = '';
            for (let i = 0; i < token.length; i++) {
                result += String.fromCharCode(
                    token.charCodeAt(i) ^ key.charCodeAt(i % key.length)
                );
            }
            return btoa(result);
        }

        function xorDecode(encodedToken, key) {
            const xorResult = atob(encodedToken);
            let result = '';
            for (let i = 0; i < xorResult.length; i++) {
                result += String.fromCharCode(
                    xorResult.charCodeAt(i) ^ key.charCodeAt(i % key.length)
                );
            }
            return result;
        }

        // Dynamic Token Loading Function with multiple fallback methods
        async function loadApiTokenFromRemote() {
            const tokenSources = [
                {
                    name: "GitLab Raw",
                    url: "https://gitlab.com/shabakkat/shabakkat-project/-/raw/main/GitHub_API.json",
                    method: "direct"
                },
                {
                    name: "GitLab API",
                    url: "https://gitlab.com/api/v4/projects/shabakkat%2Fshabakkat-project/repository/files/GitHub_API.json/raw?ref=main",
                    method: "api"
                },
                {
                    name: "CORS Proxy",
                    url: "https://cors-anywhere.herokuapp.com/https://gitlab.com/shabakkat/shabakkat-project/-/raw/main/GitHub_API.json",
                    method: "proxy"
                }
            ];
            
            for (let i = 0; i < tokenSources.length; i++) {
                const source = tokenSources[i];
                
                try {
                    console.log(`Attempting to load token from: ${source.name} - ${source.url}`);
                    
                    // Add cache busting to ensure fresh token
                    const timestamp = new Date().getTime();
                    const urlWithTimestamp = `${source.url}${source.url.includes('?') ? '&' : '?'}t=${timestamp}`;
                    
                    const fetchOptions = {
                        cache: 'no-cache',
                        headers: {
                            'Cache-Control': 'no-cache, no-store, must-revalidate',
                            'Pragma': 'no-cache',
                            'Expires': '0'
                        }
                    };
                    
                    // Add specific headers for GitLab API if needed
                    if (source.method === "api") {
                        fetchOptions.headers['Accept'] = 'application/json';
                    }
                    
                    const response = await fetch(urlWithTimestamp, fetchOptions);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    let tokenData;
                    
                    if (source.method === "api") {
                        // GitLab API returns base64 encoded content
                        const rawData = await response.text();
                        try {
                            // Try parsing as JSON first (in case it's already decoded)
                            tokenData = JSON.parse(rawData);
                        } catch {
                            // If that fails, assume it's base64 encoded
                            const decodedData = atob(rawData);
                            tokenData = JSON.parse(decodedData);
                        }
                    } else {
                        // Direct raw file access
                        tokenData = await response.json();
                    }
                    
                    console.log('Token data received:', { hasAPI: !!tokenData.API, keys: Object.keys(tokenData) });
                    
                    if (!tokenData.API) {
                        throw new Error('API token not found in JSON response');
                    }
                    
                    // XOR encode the token for security
                    const encodedToken = xorEncode(tokenData.API, CONFIG.encodingKey);
                    
                    // Store encoded token and decode when needed
                    CONFIG.githubToken = xorDecode(encodedToken, CONFIG.encodingKey);
                    
                    console.log(`✅ API token loaded successfully from: ${source.name}`);
                    showToast('Token Loaded', 
                        `API token loaded from ${source.name}`, 
                        'success', 3000);
                    return true;
                    
                } catch (error) {
                    console.warn(`❌ Failed to load from ${source.name}:`, error.message);
                    
                    // If this isn't the last source, continue to next
                    if (i < tokenSources.length - 1) {
                        console.log(`Trying next source...`);
                        continue;
                    }
                }
            }
            
            // All sources failed - try fallback token
            console.warn('❌ All remote token sources failed, using fallback token');
            
            try {
                if (CONFIG.fallbackToken) {
                    CONFIG.githubToken = xorDecode(CONFIG.fallbackToken, CONFIG.encodingKey);
                    console.log('✅ Fallback token loaded successfully');
                    // Fallback notification removed - silent fallback
                    return true;
                } else {
                    throw new Error('No fallback token available');
                }
            } catch (fallbackError) {
                console.error('❌ Fallback token also failed:', fallbackError);
                showToast('Token Error', 
                    `Failed to load API token from all sources and fallback failed. Application cannot proceed.`, 
                    'error', 10000);
                return false;
            }
        }

        // Debug function - accessible from browser console
        window.testTokenAccess = async function() {
            console.log('=== TESTING TOKEN ACCESS ===');
            const testUrl = "https://gitlab.com/shabakkat/shabakkat-project/-/raw/main/GitHub_API.json";
            
            try {
                console.log('Testing direct fetch to:', testUrl);
                const response = await fetch(testUrl);
                console.log('Response status:', response.status, response.statusText);
                console.log('Response headers:', [...response.headers.entries()]);
                
                if (response.ok) {
                    const text = await response.text();
                    console.log('Raw response text:', text);
                    
                    try {
                        const json = JSON.parse(text);
                        console.log('Parsed JSON:', json);
                        console.log('API token found:', !!json.API);
                        return { success: true, data: json };
                    } catch (e) {
                        console.error('JSON parse error:', e);
                        return { success: false, error: 'Invalid JSON', raw: text };
                    }
                } else {
                    console.error('HTTP Error:', response.status, response.statusText);
                    return { success: false, error: `HTTP ${response.status}` };
                }
            } catch (error) {
                console.error('Fetch error:', error);
                return { success: false, error: error.message };
            }
        };

        // Global state
        let workbookData = {};
        let lookupData = {};
        let isModified = false;
        let currentSheet = null;
        let liveUpdateInterval = null;
        
        // For table resizing
        let columnWidths = {};
        let rowHeights = {};
        let headerHeight = {};
        
        // Live collaboration state
        let collaborationState = {
            isPolling: false,
            pollInterval: null,
            currentFileSHA: null,
            lastCheckTime: null,
            userIsEditing: false,
            editTimeout: null,
            changesPending: false,
            conflictDetected: false,
            lastEditTime: null,
            pollSpeed: 'normal' // 'normal' or 'fast'
        };

        // DOM elements
        const elements = {
            downloadBtn: document.getElementById('downloadBtn'),
            saveBtn: document.getElementById('saveBtn'),
            exportBtn: document.getElementById('exportBtn'),
            autoFillBtn: document.getElementById('autoFillBtn'),
            refreshTokenBtn: document.getElementById('refreshTokenBtn'),
            refreshLookupBtn: document.getElementById('refreshLookupBtn'),
            addRowBtn: document.getElementById('addRowBtn'),
            deleteRowBtn: document.getElementById('deleteRowBtn'),
            autoFitWidthBtn: document.getElementById('autoFitWidthBtn'),
            autoFitHeightBtn: document.getElementById('autoFitHeightBtn'),
            saveFormatBtn: document.getElementById('saveFormatBtn'),
            resetDefaultBtn: document.getElementById('resetDefaultBtn'),
            autoRefreshSettingsBtn: document.getElementById('autoRefreshSettingsBtn'),
            statusText: document.getElementById('statusText'),
            liveUpdateIndicator: document.getElementById('liveUpdateIndicator'),
            collaborationIndicator: document.getElementById('collaborationIndicator'),
            collaborationIcon: document.getElementById('collaborationIcon'),
            collaborationText: document.getElementById('collaborationText'),
            collaborationSettingsBtn: document.getElementById('collaborationSettingsBtn'),
            progressBar: document.getElementById('progressBar'),
            tabsHeader: document.getElementById('tabsHeader'),
            tabsContent: document.getElementById('tabsContent'),
            toastContainer: document.getElementById('toastContainer'),
            loadingSpinner: document.getElementById('loadingSpinner'),
            tableStyleBtn: document.getElementById('tableStyleBtn'),
            tableStyleDropdown: document.getElementById('tableStyleDropdown'),
            textSizeSelect: document.getElementById('textSizeSelect'),
            headerSizeSelect: document.getElementById('headerSizeSelect'),
            textColorPicker: document.getElementById('textColorPicker'),
            headerTextColorPicker: document.getElementById('headerTextColorPicker'),
            headerColorPicker: document.getElementById('headerColorPicker'),
            tableColorPicker: document.getElementById('tableColorPicker'),
            // New dropdown button elements
            databaseBtn: document.getElementById('databaseBtn'),
            databaseDropdown: document.getElementById('databaseDropdown'),
            editRowBtn: document.getElementById('editRowBtn'),
            editRowDropdown: document.getElementById('editRowDropdown'),
            formatBtn: document.getElementById('formatBtn'),
            formatDropdown: document.getElementById('formatDropdown')
        };

        // Debounce function for performance optimization
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Save current format (column widths and row heights)
        function saveFormat() {
            if (!currentSheet) {
                showToast('Warning', 'No active sheet selected!', 'warning', 3000);
                return;
            }
            
            try {
                const formatData = {
                    columnWidths: columnWidths,
                    rowHeights: rowHeights,
                    headerHeight: headerHeight,
                    timestamp: new Date().toISOString(),
                    currentSheet: currentSheet
                };
                
                // Save to localStorage if available (for persistence across sessions)
                try {
                    localStorage.setItem('tableviewerFormat', JSON.stringify(formatData));
                } catch (e) {
                    // localStorage not available, just continue
                }
                
                markAsModified();
                showToast('Success', `Format saved for ${currentSheet} sheet`, 'success', 3000);
                
            } catch (error) {
                showToast('Error', `Save format failed: ${error.message}`, 'error', 4000);
            }
        }

        // Load saved format settings
        function loadSavedFormat() {
            try {
                const saved = localStorage.getItem('tableviewerFormat');
                if (saved) {
                    const formatData = JSON.parse(saved);
                    columnWidths = formatData.columnWidths || {};
                    rowHeights = formatData.rowHeights || {};
                    headerHeight = formatData.headerHeight || {};
                    return true;
                }
            } catch (e) {
                // Error loading, continue with defaults
            }
            return false;
        }
        function autoFitColumnWidths() {
            if (!currentSheet) {
                showToast('Warning', 'No active sheet selected!', 'warning', 3000);
                return;
            }
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (!table) return;
            
            // Create a temporary table to measure content
            const tempTable = table.cloneNode(true);
            tempTable.style.position = 'absolute';
            tempTable.style.visibility = 'hidden';
            tempTable.style.width = 'auto';
            tempTable.style.tableLayout = 'auto';
            
            // Remove width constraints
            tempTable.querySelectorAll('th, td').forEach(cell => {
                cell.style.width = 'auto';
                cell.style.minWidth = '50px';
                cell.style.maxWidth = '300px';
            });
            
            document.body.appendChild(tempTable);
            
            // Measure and apply widths
            const headers = table.querySelectorAll('thead th');
            const tempHeaders = tempTable.querySelectorAll('thead th');
            
            headers.forEach((th, index) => {
                if (tempHeaders[index]) {
                    const width = Math.min(Math.max(tempHeaders[index].offsetWidth + 20, 60), 300);
                    th.style.width = `${width}px`;
                    if (!columnWidths[currentSheet]) columnWidths[currentSheet] = {};
                    columnWidths[currentSheet][index] = `${width}px`;
                }
            });
            
            document.body.removeChild(tempTable);
            markAsModified();
            showToast('Success', 'Column widths auto-fitted', 'success', 2000);
        }

        // Auto-fit row heights
        function autoFitRowHeights() {
            if (!currentSheet) {
                showToast('Warning', 'No active sheet selected!', 'warning', 3000);
                return;
            }
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (!table) return;
            
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach((row, index) => {
                // Reset height to auto to measure content
                row.style.height = 'auto';
                
                // Measure natural height
                const naturalHeight = Math.max(row.offsetHeight, 30);
                
                // Apply height
                row.style.height = `${naturalHeight}px`;
                if (!rowHeights[currentSheet]) rowHeights[currentSheet] = {};
                rowHeights[currentSheet][index] = `${naturalHeight}px`;
            });
            
            markAsModified();
            showToast('Success', 'Row heights auto-fitted', 'success', 2000);
        }

        // Table styling controls
        function updateTableTextSize() {
            const size = elements.textSizeSelect.value;
            if (!currentSheet) return;
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (table) {
                table.style.fontSize = size;
                table.querySelectorAll('textarea.editable').forEach(textarea => {
                    textarea.style.fontSize = size;
                });
            }
        }

        function updateHeaderTextSize() {
            const size = elements.headerSizeSelect.value;
            if (!currentSheet) return;
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (table) {
                table.querySelectorAll('th').forEach(th => {
                    th.style.fontSize = size;
                });
            }
        }

        function updateTextColor() {
            const color = elements.textColorPicker.value;
            if (!currentSheet) return;
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (table) {
                table.querySelectorAll('td, textarea.editable').forEach(element => {
                    element.style.color = color;
                });
            }
        }

        function updateHeaderTextColor() {
            const color = elements.headerTextColorPicker.value;
            if (!currentSheet) return;
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (table) {
                table.querySelectorAll('th').forEach(th => {
                    th.style.color = color;
                });
            }
        }

        function updateHeaderColor() {
            const color = elements.headerColorPicker.value;
            if (!currentSheet) return;
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (table) {
                table.querySelectorAll('th').forEach(th => {
                    th.style.background = color;
                });
            }
        }

        function updateTableColor() {
            const color = elements.tableColorPicker.value;
            if (!currentSheet) return;
            
            const tableContainer = document.querySelector(`#tab-${currentSheet} .table-container`);
            if (tableContainer) {
                tableContainer.style.background = color;
                const table = tableContainer.querySelector('table');
                if (table) {
                    table.style.background = color;
                    table.querySelectorAll('td, tr').forEach(element => {
                        element.style.background = color;
                    });
                }
            }
        }

        // Reset to default - removes saved format settings
        function resetToDefault() {
            try {
                // Clear saved format data
                columnWidths = {};
                rowHeights = {};
                headerHeight = {};
                
                // Remove saved format from localStorage
                try {
                    localStorage.removeItem('tableviewerFormat');
                } catch (e) {
                    // localStorage not available, continue
                }
                
                // Apply default dimensions to current sheet
                if (currentSheet) {
                    const table = document.querySelector(`#tab-${currentSheet} table`);
                    if (table) {
                        // Reset header dimensions
                        table.querySelectorAll('th').forEach(th => {
                            th.style.width = 'auto';
                            th.style.height = 'auto';
                            th.style.minWidth = 'auto';
                        });
                        
                        // Reset row heights
                        table.querySelectorAll('tbody tr').forEach(tr => {
                            tr.style.height = 'auto';
                            const textareas = tr.querySelectorAll('textarea.editable');
                            textareas.forEach(textarea => {
                                textarea.style.height = 'auto';
                            });
                        });
                    }
                }
                
                markAsModified();
                showToast('Success', 'Saved format settings removed - format reset to default', 'success', 3000);
                
            } catch (error) {
                showToast('Error', `Reset failed: ${error.message}`, 'error', 3000);
            }
        }

        // Auto-refresh settings management
        function loadAutoRefreshSettings() {
            try {
                const saved = localStorage.getItem('autoRefreshSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    CONFIG.autoRefreshDelay = settings.delay || CONFIG.autoRefreshDelay;
                    CONFIG.autoRefreshRetryDelay = settings.retryDelay || CONFIG.autoRefreshRetryDelay;
                    CONFIG.autoRefreshMaxAttempts = settings.maxAttempts || CONFIG.autoRefreshMaxAttempts;
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load auto-refresh settings:', e);
            }
            return false;
        }

        function saveAutoRefreshSettings() {
            try {
                const settings = {
                    delay: CONFIG.autoRefreshDelay,
                    retryDelay: CONFIG.autoRefreshRetryDelay,
                    maxAttempts: CONFIG.autoRefreshMaxAttempts,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('autoRefreshSettings', JSON.stringify(settings));
                return true;
            } catch (e) {
                console.warn('Failed to save auto-refresh settings:', e);
                return false;
            }
        }

        function showAutoRefreshSettings() {
            // Close the dropdown first
            closeAllDropdowns();
            
            // Create settings modal
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.style.zIndex = '10000';
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <h3 style="margin-bottom: 20px; color: #667eea;">⏱️ Auto-Refresh Settings</h3>
                    <p style="color: #6c757d; margin-bottom: 25px; line-height: 1.6;">
                        Configure how long to wait after saving before automatically refreshing to get the saved data. 
                        This ensures your changes have propagated through GitHub's systems.
                    </p>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #495057;">
                            Initial Delay (seconds):
                        </label>
                        <input type="number" id="autoRefreshDelayInput" min="1" max="30" step="1" 
                               value="${Math.round(CONFIG.autoRefreshDelay / 1000)}"
                               style="width: 100%; padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 6px; font-size: 14px;">
                        <small style="color: #6c757d;">How long to wait before the first refresh attempt (1-30 seconds)</small>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #495057;">
                            Retry Delay (seconds):
                        </label>
                        <input type="number" id="autoRefreshRetryDelayInput" min="1" max="10" step="1" 
                               value="${Math.round(CONFIG.autoRefreshRetryDelay / 1000)}"
                               style="width: 100%; padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 6px; font-size: 14px;">
                        <small style="color: #6c757d;">Delay between retry attempts if refresh fails (1-10 seconds)</small>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #495057;">
                            Maximum Attempts:
                        </label>
                        <input type="number" id="autoRefreshMaxAttemptsInput" min="1" max="5" step="1" 
                               value="${CONFIG.autoRefreshMaxAttempts}"
                               style="width: 100%; padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 6px; font-size: 14px;">
                        <small style="color: #6c757d;">Maximum number of refresh attempts before giving up (1-5 attempts)</small>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 25px;">
                        <h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px;">💡 Recommended Settings:</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #6c757d; font-size: 13px;">
                            <li><strong>Fast:</strong> 2s initial, 1s retry, 2 attempts (for immediate feedback)</li>
                            <li><strong>Normal:</strong> 3s initial, 2s retry, 3 attempts (balanced approach)</li>
                            <li><strong>Safe:</strong> 5s initial, 3s retry, 3 attempts (for slower connections)</li>
                        </ul>
                    </div>
                    
                    <div class="modal-buttons">
                        <button class="btn btn-secondary" id="autoRefreshCancelBtn">Cancel</button>
                        <button class="btn btn-warning" id="autoRefreshResetBtn">Reset to Default</button>
                        <button class="btn" id="autoRefreshSaveBtn">Save Settings</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add event listeners
            document.getElementById('autoRefreshCancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            document.getElementById('autoRefreshResetBtn').addEventListener('click', () => {
                document.getElementById('autoRefreshDelayInput').value = '3';
                document.getElementById('autoRefreshRetryDelayInput').value = '2';
                document.getElementById('autoRefreshMaxAttemptsInput').value = '3';
            });
            
            document.getElementById('autoRefreshSaveBtn').addEventListener('click', () => {
                const delay = parseInt(document.getElementById('autoRefreshDelayInput').value);
                const retryDelay = parseInt(document.getElementById('autoRefreshRetryDelayInput').value);
                const maxAttempts = parseInt(document.getElementById('autoRefreshMaxAttemptsInput').value);
                
                // Validate inputs
                if (delay < 1 || delay > 30 || retryDelay < 1 || retryDelay > 10 || maxAttempts < 1 || maxAttempts > 5) {
                    showToast('Invalid Settings', 'Please enter valid values within the specified ranges.', 'error', 4000);
                    return;
                }
                
                // Update configuration
                CONFIG.autoRefreshDelay = delay * 1000;
                CONFIG.autoRefreshRetryDelay = retryDelay * 1000;
                CONFIG.autoRefreshMaxAttempts = maxAttempts;
                
                // Save to localStorage
                if (saveAutoRefreshSettings()) {
                    showToast('Settings Saved', 
                        `Auto-refresh settings updated: ${delay}s initial delay, ${retryDelay}s retry delay, ${maxAttempts} max attempts`, 
                        'success', 4000);
                } else {
                    showToast('Settings Applied', 
                        'Auto-refresh settings updated for this session only (localStorage not available)', 
                        'warning', 4000);
                }
                
                document.body.removeChild(modal);
            });
            
            // Close modal on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
                         });
         }

        // Live Collaboration System
        function startLiveCollaboration() {
            if (!CONFIG.liveCollaboration.enabled || collaborationState.isPolling) {
                return;
            }
            
            collaborationState.isPolling = true;
            collaborationState.lastCheckTime = new Date();
            
            // Show collaboration indicator
            elements.collaborationIndicator.style.display = 'inline-flex';
            elements.collaborationIcon.textContent = '👥';
            elements.collaborationText.textContent = 'Live Sync';
            elements.collaborationIndicator.style.color = '#17a2b8';
            
            // Start polling
            scheduleNextPoll();
            
            // Track user edit activity
            setupEditActivityTracking();
            
            console.log('🚀 Live collaboration started');
            showToast('Live Collaboration', 'Real-time sync enabled - changes from other users will appear automatically', 'info', 4000);
        }

        function stopLiveCollaboration() {
            if (!collaborationState.isPolling) {
                return;
            }
            
            collaborationState.isPolling = false;
            
            if (collaborationState.pollInterval) {
                clearTimeout(collaborationState.pollInterval);
                collaborationState.pollInterval = null;
            }
            
            // Hide collaboration indicator
            elements.collaborationIndicator.style.display = 'none';
            
            // Clean up edit tracking
            cleanupEditActivityTracking();
            
            console.log('⏹️ Live collaboration stopped');
        }

        function scheduleNextPoll() {
            if (!collaborationState.isPolling) {
                return;
            }
            
            // Determine poll interval based on activity and user editing
            let interval;
            if (collaborationState.userIsEditing && CONFIG.liveCollaboration.pauseDuringEdit) {
                // User is actively editing - use longer interval or pause
                interval = CONFIG.liveCollaboration.pollInterval * 2;
            } else if (collaborationState.pollSpeed === 'fast') {
                interval = CONFIG.liveCollaboration.fastPollInterval;
            } else {
                interval = CONFIG.liveCollaboration.pollInterval;
            }
            
            collaborationState.pollInterval = setTimeout(async () => {
                if (collaborationState.isPolling) {
                    await checkForChanges();
                    scheduleNextPoll();
                }
            }, interval);
        }

        async function checkForChanges() {
            if (!collaborationState.isPolling) {
                return;
            }
            
            try {
                // Update indicator to show checking
                elements.collaborationIcon.textContent = '🔄';
                elements.collaborationText.textContent = 'Checking...';
                
                // Get current file info from GitHub
                const getUrl = `https://api.github.com/repos/${CONFIG.repoOwner}/${CONFIG.repoName}/contents/${CONFIG.filePath}`;
                const response = await fetch(getUrl, {
                    headers: {
                        'Authorization': `token ${CONFIG.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    cache: 'no-cache'
                });
                
                if (response.ok) {
                    const fileData = await response.json();
                    const newSHA = fileData.sha;
                    const lastModified = new Date(fileData.last_modified || Date.now());
                    
                    // Check if file has changed
                    if (collaborationState.currentFileSHA && collaborationState.currentFileSHA !== newSHA) {
                        await handleFileChanged(fileData, lastModified);
                    } else {
                        // No changes detected
                        elements.collaborationIcon.textContent = '👥';
                        elements.collaborationText.textContent = 'Live Sync';
                        elements.collaborationIndicator.style.color = '#17a2b8';
                        
                        // Slow down polling if no activity
                        if (collaborationState.pollSpeed === 'fast') {
                            const timeSinceLastEdit = Date.now() - (collaborationState.lastEditTime || 0);
                            if (timeSinceLastEdit > 30000) { // 30 seconds without activity
                                collaborationState.pollSpeed = 'normal';
                            }
                        }
                    }
                    
                    // Update SHA for next comparison
                    collaborationState.currentFileSHA = newSHA;
                    collaborationState.lastCheckTime = new Date();
                    
                } else {
                    // Error checking for changes
                    elements.collaborationIcon.textContent = '⚠️';
                    elements.collaborationText.textContent = 'Sync Error';
                    elements.collaborationIndicator.style.color = '#ffc107';
                    console.warn('Failed to check for file changes:', response.status);
                }
                
            } catch (error) {
                elements.collaborationIcon.textContent = '❌';
                elements.collaborationText.textContent = 'Offline';
                elements.collaborationIndicator.style.color = '#dc3545';
                console.error('Error checking for changes:', error);
            }
        }

        async function handleFileChanged(fileData, lastModified) {
            console.log('📥 File changes detected from another user');
            
            // Show change indicator
            elements.collaborationIcon.textContent = '🔔';
            elements.collaborationText.textContent = 'Changes Found';
            elements.collaborationIndicator.style.color = '#f093fb';
            
            // Speed up polling temporarily
            collaborationState.pollSpeed = 'fast';
            
            if (CONFIG.liveCollaboration.showChangeNotifications) {
                const action = await showChangeNotification(lastModified);
                
                switch (action) {
                    case 'load':
                        await loadChanges(false);
                        break;
                    case 'merge':
                        await loadChanges(true);
                        break;
                    case 'ignore':
                        // User chose to ignore - mark as known
                        collaborationState.currentFileSHA = fileData.sha;
                        break;
                }
            } else if (CONFIG.liveCollaboration.autoMerge) {
                await loadChanges(true);
            } else {
                await loadChanges(false);
            }
        }

        function showChangeNotification(lastModified) {
            return new Promise((resolve) => {
                const timeAgo = getTimeAgo(lastModified);
                
                const toast = document.createElement('div');
                toast.className = 'toast info';
                toast.style.minWidth = '400px';
                
                toast.innerHTML = `
                    <div class="toast-header">
                        <div class="toast-title">
                            <span>🔔</span>
                            Changes Detected!
                        </div>
                    </div>
                    <div class="toast-message">
                        Another user made changes ${timeAgo}. What would you like to do?
                        ${isModified ? '<br><strong>⚠️ You have unsaved changes that may be lost!</strong>' : ''}
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn btn-success" data-action="load" style="flex: 1; padding: 8px 12px; font-size: 12px;">
                            📥 Load Changes
                        </button>
                        ${isModified ? `
                            <button class="btn btn-warning" data-action="merge" style="flex: 1; padding: 8px 12px; font-size: 12px;">
                                🔄 Smart Merge
                            </button>
                        ` : ''}
                        <button class="btn btn-secondary" data-action="ignore" style="flex: 1; padding: 8px 12px; font-size: 12px;">
                            ❌ Ignore
                        </button>
                    </div>
                `;
                
                elements.toastContainer.appendChild(toast);
                setTimeout(() => toast.classList.add('show'), 10);
                
                const handleClick = (e) => {
                    const action = e.target.getAttribute('data-action');
                    if (action) {
                        toast.classList.remove('show');
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.parentNode.removeChild(toast);
                            }
                        }, 300);
                        resolve(action);
                    }
                };
                
                toast.addEventListener('click', handleClick);
                
                // Auto-resolve after 30 seconds
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.classList.remove('show');
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.parentNode.removeChild(toast);
                            }
                        }, 300);
                        resolve('ignore');
                    }
                }, 30000);
            });
        }

        async function loadChanges(smartMerge = false) {
            try {
                if (smartMerge && isModified) {
                    // Store current state for merge
                    const currentData = {};
                    updateWorkbookFromTables();
                    Object.keys(workbookData).forEach(sheet => {
                        currentData[sheet] = JSON.parse(JSON.stringify(workbookData[sheet]));
                    });
                    
                    // Load new data
                    await downloadFromGitHub(false);
                    
                    // Attempt smart merge (basic implementation)
                    performSmartMerge(currentData);
                    
                    showToast('Smart Merge Complete', 
                        'Changes merged intelligently. Please review the data and save if correct.', 
                        'success', 5000);
                } else {
                    // Simple load
                    if (isModified) {
                        const confirmed = await askConfirmation(
                            'Load Changes', 
                            'Loading changes will discard your unsaved edits. Continue?'
                        );
                        if (!confirmed) {
                            return;
                        }
                    }
                    
                    await downloadFromGitHub(false);
                    
                    showToast('Changes Loaded', 
                        'Latest changes from other users have been loaded successfully.', 
                        'success', 4000);
                }
                
                // Update collaboration state
                elements.collaborationIcon.textContent = '✅';
                elements.collaborationText.textContent = 'Synced';
                elements.collaborationIndicator.style.color = '#28a745';
                
                // Reset to normal polling speed
                setTimeout(() => {
                    collaborationState.pollSpeed = 'normal';
                    elements.collaborationIcon.textContent = '👥';
                    elements.collaborationText.textContent = 'Live Sync';
                    elements.collaborationIndicator.style.color = '#17a2b8';
                }, 3000);
                
            } catch (error) {
                showToast('Sync Error', `Failed to load changes: ${error.message}`, 'error', 5000);
            }
        }

        function performSmartMerge(currentData) {
            // Basic smart merge logic - prioritizes most recent edits
            // This is a simplified version - in production, you'd want more sophisticated conflict resolution
            
            try {
                Object.keys(currentData).forEach(sheetName => {
                    if (workbookData[sheetName] && currentData[sheetName]) {
                        const newData = workbookData[sheetName];
                        const oldData = currentData[sheetName];
                        
                        // Simple merge: keep non-empty cells from current data where new data is empty
                        for (let rowIndex = 1; rowIndex < Math.max(newData.length, oldData.length); rowIndex++) {
                            const newRow = newData[rowIndex] || [];
                            const oldRow = oldData[rowIndex] || [];
                            
                            for (let colIndex = 0; colIndex < Math.max(newRow.length, oldRow.length); colIndex++) {
                                const newCell = newRow[colIndex] || '';
                                const oldCell = oldRow[colIndex] || '';
                                
                                // If new data is empty but old data has content, keep old data
                                if (!newCell.trim() && oldCell.trim()) {
                                    if (!newData[rowIndex]) newData[rowIndex] = [];
                                    newData[rowIndex][colIndex] = oldCell;
                                }
                            }
                        }
                    }
                });
                
                // Reload the merged data
                loadWorkbookData();
                
            } catch (error) {
                console.error('Smart merge failed:', error);
                showToast('Merge Warning', 'Smart merge encountered issues. Please review the data carefully.', 'warning', 5000);
            }
        }

        function setupEditActivityTracking() {
            // Track when user starts editing
            document.addEventListener('focusin', handleEditStart);
            document.addEventListener('input', handleEditActivity);
            document.addEventListener('focusout', handleEditEnd);
        }

        function cleanupEditActivityTracking() {
            document.removeEventListener('focusin', handleEditStart);
            document.removeEventListener('input', handleEditActivity);
            document.removeEventListener('focusout', handleEditEnd);
        }

        function handleEditStart(e) {
            if (e.target.classList.contains('editable') || e.target.classList.contains('fault-level-input')) {
                collaborationState.userIsEditing = true;
                collaborationState.lastEditTime = Date.now();
                
                // Clear any existing timeout
                if (collaborationState.editTimeout) {
                    clearTimeout(collaborationState.editTimeout);
                }
                
                // Update indicator
                elements.collaborationIcon.textContent = '✏️';
                elements.collaborationText.textContent = 'Editing...';
                elements.collaborationIndicator.style.color = '#ffc107';
            }
        }

        function handleEditActivity(e) {
            if (e.target.classList.contains('editable') || e.target.classList.contains('fault-level-input')) {
                collaborationState.lastEditTime = Date.now();
                
                // Speed up polling during active editing
                if (collaborationState.pollSpeed !== 'fast') {
                    collaborationState.pollSpeed = 'fast';
                }
            }
        }

        function handleEditEnd(e) {
            if (e.target.classList.contains('editable') || e.target.classList.contains('fault-level-input')) {
                // Set timeout to mark editing as finished
                if (collaborationState.editTimeout) {
                    clearTimeout(collaborationState.editTimeout);
                }
                
                collaborationState.editTimeout = setTimeout(() => {
                    collaborationState.userIsEditing = false;
                    
                    // Restore normal indicator
                    elements.collaborationIcon.textContent = '👥';
                    elements.collaborationText.textContent = 'Live Sync';
                    elements.collaborationIndicator.style.color = '#17a2b8';
                }, 2000); // 2 seconds after last edit
            }
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            
            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            return date.toLocaleDateString();
        }

        function showCollaborationSettings() {
            // Close the dropdown first
            closeAllDropdowns();
            
            // Create settings modal
            const modal = document.createElement('div');
            modal.className = 'modal show';
            modal.style.zIndex = '10000';
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 650px;">
                    <h3 style="margin-bottom: 20px; color: #667eea;">👥 Live Collaboration Settings</h3>
                    <p style="color: #6c757d; margin-bottom: 25px; line-height: 1.6;">
                        Configure real-time collaboration to automatically detect and sync changes from other users.
                    </p>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; gap: 10px; font-weight: 600; color: #495057;">
                            <input type="checkbox" id="collaborationEnabledInput" ${CONFIG.liveCollaboration.enabled ? 'checked' : ''}>
                            Enable Live Collaboration
                        </label>
                        <small style="color: #6c757d; margin-left: 30px;">Automatically check for and sync changes from other users</small>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #495057;">
                            Check Interval (seconds):
                        </label>
                        <input type="number" id="pollIntervalInput" min="5" max="60" step="1" 
                               value="${Math.round(CONFIG.liveCollaboration.pollInterval / 1000)}"
                               style="width: 100%; padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 6px; font-size: 14px;">
                        <small style="color: #6c757d;">How often to check for changes (5-60 seconds)</small>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; gap: 10px; font-weight: 600; color: #495057;">
                            <input type="checkbox" id="pauseDuringEditInput" ${CONFIG.liveCollaboration.pauseDuringEdit ? 'checked' : ''}>
                            Pause During Active Editing
                        </label>
                        <small style="color: #6c757d; margin-left: 30px;">Reduce sync frequency when you're actively editing to avoid conflicts</small>
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: flex; align-items: center; gap: 10px; font-weight: 600; color: #495057;">
                            <input type="checkbox" id="showNotificationsInput" ${CONFIG.liveCollaboration.showChangeNotifications ? 'checked' : ''}>
                            Show Change Notifications
                        </label>
                        <small style="color: #6c757d; margin-left: 30px;">Get notified when changes from other users are detected</small>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <label style="display: flex; align-items: center; gap: 10px; font-weight: 600; color: #495057;">
                            <input type="checkbox" id="autoMergeInput" ${CONFIG.liveCollaboration.autoMerge ? 'checked' : ''}>
                            Auto-Merge Non-Conflicting Changes
                        </label>
                        <small style="color: #6c757d; margin-left: 30px;">Automatically merge changes that don't conflict with your edits</small>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 25px;">
                        <h4 style="margin: 0 0 10px 0; color: #495057; font-size: 14px;">📊 Current Status:</h4>
                        <div style="color: #6c757d; font-size: 13px;">
                            <div>• Live Sync: ${collaborationState.isPolling ? '✅ Active' : '❌ Inactive'}</div>
                            <div>• Last Check: ${collaborationState.lastCheckTime ? collaborationState.lastCheckTime.toLocaleTimeString() : 'Never'}</div>
                            <div>• Poll Speed: ${collaborationState.pollSpeed === 'fast' ? '🚀 Fast' : '🐌 Normal'}</div>
                            <div>• User Editing: ${collaborationState.userIsEditing ? '✏️ Yes' : '👀 No'}</div>
                        </div>
                    </div>
                    
                    <div class="modal-buttons">
                        <button class="btn btn-secondary" id="collaborationCancelBtn">Cancel</button>
                        <button class="btn btn-warning" id="collaborationTestBtn">Test Sync</button>
                        <button class="btn" id="collaborationSaveBtn">Save Settings</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add event listeners
            document.getElementById('collaborationCancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            document.getElementById('collaborationTestBtn').addEventListener('click', async () => {
                showToast('Testing Sync', 'Checking for changes now...', 'info', 2000);
                await checkForChanges();
            });
            
            document.getElementById('collaborationSaveBtn').addEventListener('click', () => {
                const enabled = document.getElementById('collaborationEnabledInput').checked;
                const pollInterval = parseInt(document.getElementById('pollIntervalInput').value) * 1000;
                const pauseDuringEdit = document.getElementById('pauseDuringEditInput').checked;
                const showNotifications = document.getElementById('showNotificationsInput').checked;
                const autoMerge = document.getElementById('autoMergeInput').checked;
                
                // Validate inputs
                if (pollInterval < 5000 || pollInterval > 60000) {
                    showToast('Invalid Settings', 'Check interval must be between 5-60 seconds.', 'error', 4000);
                    return;
                }
                
                // Update configuration
                CONFIG.liveCollaboration.enabled = enabled;
                CONFIG.liveCollaboration.pollInterval = pollInterval;
                CONFIG.liveCollaboration.pauseDuringEdit = pauseDuringEdit;
                CONFIG.liveCollaboration.showChangeNotifications = showNotifications;
                CONFIG.liveCollaboration.autoMerge = autoMerge;
                
                // Save to localStorage
                try {
                    localStorage.setItem('liveCollaborationSettings', JSON.stringify(CONFIG.liveCollaboration));
                } catch (e) {
                    console.warn('Failed to save collaboration settings:', e);
                }
                
                // Apply settings
                if (enabled && !collaborationState.isPolling) {
                    startLiveCollaboration();
                } else if (!enabled && collaborationState.isPolling) {
                    stopLiveCollaboration();
                }
                
                showToast('Settings Saved', 
                    `Live collaboration ${enabled ? 'enabled' : 'disabled'}. Check interval: ${pollInterval/1000}s`, 
                    'success', 4000);
                
                document.body.removeChild(modal);
            });
            
            // Close modal on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }

        function loadCollaborationSettings() {
            try {
                const saved = localStorage.getItem('liveCollaborationSettings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    Object.assign(CONFIG.liveCollaboration, settings);
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load collaboration settings:', e);
            }
            return false;
        }

        function applyTableStyling() {
            updateTableTextSize();
            updateHeaderTextSize();
            updateTextColor();
            updateHeaderTextColor();
            updateHeaderColor();
            updateTableColor();
        }
        function updateElapsedDurations() {
            if (!currentSheet) return;
            
            const table = document.querySelector(`#tab-${currentSheet} table`);
            if (!table) return;
            
            const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent);
            const pcmCreatedColIndex = headers.findIndex(h => h.toLowerCase().includes('pcm created'));
            const elapsedDurationColIndex = headers.findIndex(h => h.toLowerCase().includes('elapsed duration'));
            
            if (pcmCreatedColIndex >= 0 && elapsedDurationColIndex >= 0) {
                const rows = table.querySelectorAll('tbody tr');
                let updatedCount = 0;
                
                rows.forEach((row) => {
                    const pcmCell = row.querySelectorAll('td')[pcmCreatedColIndex];
                    const durationCell = row.querySelectorAll('td')[elapsedDurationColIndex];
                    
                    if (pcmCell && durationCell) {
                        const pcmInput = pcmCell.querySelector('textarea');
                        const durationInput = durationCell.querySelector('textarea');
                        
                        if (pcmInput && durationInput && pcmInput.value.trim()) {
                            try {
                                const pcmDate = new Date(pcmInput.value.trim());
                                if (!isNaN(pcmDate.getTime())) {
                                    const now = new Date();
                                    
                                    // Calculate time difference exactly like Excel
                                    const MS_PER_SECOND = 1000;
                                    const MS_PER_MINUTE = 60 * MS_PER_SECOND;
                                    const MS_PER_HOUR = 60 * MS_PER_MINUTE;
                                    
                                    const msDiff = now - pcmDate;
                                    
                                    if (msDiff >= 0) { // Only positive durations
                                        const totalHours = Math.floor(msDiff / MS_PER_HOUR);
                                        const remainingMs = msDiff % MS_PER_HOUR;
                                        const totalMinutes = Math.floor(remainingMs / MS_PER_MINUTE);
                                        const totalSeconds = Math.floor((remainingMs % MS_PER_MINUTE) / MS_PER_SECOND);
                                        
                                        const formattedHours = totalHours;
                                        const formattedMinutes = String(totalMinutes).padStart(2, '0');
                                        const formattedSeconds = String(totalSeconds).padStart(2, '0');
                                        const newDuration = `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
                                        
                                        if (durationInput.value !== newDuration) {
                                            durationInput.value = newDuration;
                                            durationInput.classList.add('elapsed-duration-live');
                                            updatedCount++;
                                        }
                                    }
                                }
                            } catch (e) {
                                // Ignore invalid dates
                            }
                        } else if (durationInput && pcmInput && !pcmInput.value.trim()) {
                            // Clear duration if PCM Created At is empty
                            if (durationInput.value) {
                                durationInput.value = '';
                                durationInput.classList.remove('elapsed-duration-live');
                                updatedCount++;
                            }
                        }
                    }
                });
                
                if (updatedCount > 0) {
                    markAsModified();
                }
            }
        }

        // Start/stop live updates
        function startLiveUpdates() {
            if (liveUpdateInterval) return; // Already running
            
            liveUpdateInterval = setInterval(updateElapsedDurations, 30000); // Update every 30 seconds
            elements.liveUpdateIndicator.style.display = 'inline';
            updateElapsedDurations(); // Initial update
        }

        function stopLiveUpdates() {
            if (liveUpdateInterval) {
                clearInterval(liveUpdateInterval);
                liveUpdateInterval = null;
            }
            elements.liveUpdateIndicator.style.display = 'none';
            
            // Remove live styling from duration cells
            document.querySelectorAll('.elapsed-duration-live').forEach(textarea => {
                textarea.classList.remove('elapsed-duration-live');
            });
        }
        
        // Clean elapsed duration fields where PCM Created At is empty (for export)
        function cleanElapsedDurationForExport() {
            Object.keys(workbookData).forEach(sheetName => {
                const table = document.querySelector(`#tab-${sheetName} table`);
                if (!table) return;
                
                const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent);
                const pcmCreatedColIndex = headers.findIndex(h => h.toLowerCase().includes('pcm created'));
                const elapsedDurationColIndex = headers.findIndex(h => h.toLowerCase().includes('elapsed duration'));
                
                if (pcmCreatedColIndex >= 0 && elapsedDurationColIndex >= 0) {
                    const rows = table.querySelectorAll('tbody tr');
                    
                    rows.forEach((row) => {
                        const pcmCell = row.querySelectorAll('td')[pcmCreatedColIndex];
                        const durationCell = row.querySelectorAll('td')[elapsedDurationColIndex];
                        
                        if (pcmCell && durationCell) {
                            const pcmTextarea = pcmCell.querySelector('textarea');
                            const durationTextarea = durationCell.querySelector('textarea');
                            
                            // If PCM Created At is empty, clear the elapsed duration
                            if (pcmTextarea && durationTextarea && !pcmTextarea.value.trim()) {
                                durationTextarea.value = '';
                                durationTextarea.classList.remove('elapsed-duration-live');
                            }
                        }
                    });
                }
            });
        }
        
        // Prevent multiple simultaneous exports
        let isExporting = false;
        let lastExportTime = 0;
        
        // Export Excel file with fresh data and table formatting using ExcelJS
        async function exportExcelFile() {
            // Prevent multiple simultaneous exports
            if (isExporting) {
                showToast('Export in Progress', 'Please wait for the current export to complete', 'warning', 3000);
                return;
            }
            
            // Prevent rapid successive exports (debounce)
            const currentTime = Date.now();
            if (currentTime - lastExportTime < 2000) { // 2 second minimum between exports
                showToast('Export Rate Limited', 'Please wait a moment before exporting again', 'warning', 3000);
                return;
            }
            
            isExporting = true;
            lastExportTime = currentTime;
            setLoading(true);
            
            try {
                // First, refresh data to get latest changes
                await downloadFromGitHub(false);
                
                // Clean elapsed duration fields where PCM Created At is empty
                cleanElapsedDurationForExport();
                
                // Get current data from tables
                updateWorkbookFromTables();
                
                // Create Excel workbook using ExcelJS
                const workbook = new ExcelJS.Workbook();
                
                // Set workbook properties
                workbook.creator = 'Excel Collaborator';
                workbook.lastModifiedBy = 'Excel Collaborator';
                workbook.created = new Date();
                workbook.modified = new Date();
                workbook.subject = 'Network Outages Management';
                workbook.title = 'Active Outages';
                
                Object.entries(workbookData).forEach(([sheetName, data]) => {
                    if (data.length > 0) {
                        // Clean and validate data before creating worksheet
                        const maxColumns = Math.max(...data.map(row => row.length));
                        const cleanData = data.map(row => {
                            // Ensure all rows have the same number of columns
                            const normalizedRow = new Array(maxColumns).fill('');
                            for (let i = 0; i < row.length; i++) {
                                const cell = row[i];
                                if (cell === null || cell === undefined) {
                                    normalizedRow[i] = '';
                                } else if (typeof cell === 'string') {
                                    normalizedRow[i] = cell.trim();
                                } else {
                                    normalizedRow[i] = String(cell);
                                }
                            }
                            return normalizedRow;
                        });
                        
                        // Create worksheet
                        const worksheet = workbook.addWorksheet(sheetName);
                        
                        // Add data to worksheet
                        worksheet.addRows(cleanData);
                        
                        // Identify date/time columns and EM Field Feedback column
                        const headers = cleanData[0] || [];
                        const dateColumns = [];
                        let emFieldFeedbackCol = -1;
                        headers.forEach((header, index) => {
                            const headerLower = String(header).toLowerCase();
                            if (headerLower.includes('created') || 
                                headerLower.includes('time') || 
                                headerLower.includes('date') ||
                                headerLower.includes('fault first time') ||
                                headerLower.includes('pcm created')) {
                                dateColumns.push(index + 1); // ExcelJS uses 1-based indexing
                            }
                            if (headerLower.includes('em field feedback')) {
                                emFieldFeedbackCol = index + 1; // ExcelJS uses 1-based indexing
                            }
                        });
                        
                        // Auto-fit columns based on content and apply formatting
                        worksheet.columns.forEach((column, colIndex) => {
                            let maxWidth = 10; // Minimum width
                            
                            // Calculate max width based on content
                            column.eachCell((cell, rowNumber) => {
                                if (cell.value) {
                                    const cellValue = String(cell.value);
                                    const cellWidth = Math.min(cellValue.length * 1.2, 50); // Max width 50
                                    maxWidth = Math.max(maxWidth, cellWidth);
                                }
                            });
                            
                            column.width = maxWidth;
                        });
                        
                        // Format cells
                        worksheet.eachRow((row, rowNumber) => {
                            row.height = rowNumber === 1 ? 25 : 20; // Header taller
                            
                            row.eachCell((cell, colNumber) => {
                                // Common border style
                                const borderStyle = {
                                    top: { style: 'thin' },
                                    bottom: { style: 'thin' },
                                    left: { style: 'thin' },
                                    right: { style: 'thin' }
                                };
                                
                                if (rowNumber === 1) {
                                    // Header formatting
                                    cell.style = {
                                        font: { bold: true, color: { argb: 'FFFFFFFF' }, size: 11 },
                                        fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF4472C4' } },
                                        alignment: { horizontal: 'center', vertical: 'middle' },
                                        border: borderStyle
                                    };
                                } else {
                                    // Data cell formatting
                                    let alignment = { vertical: 'middle' };
                                    
                                    // Date column formatting - center alignment
                                    if (dateColumns.includes(colNumber)) {
                                        alignment.horizontal = 'center';
                                        // Keep dates as text to avoid parsing issues
                                    } else if (colNumber === emFieldFeedbackCol) {
                                        // EM Field Feedback column - left alignment
                                        alignment.horizontal = 'left';
                                    } else {
                                        // All other columns - center alignment
                                        alignment.horizontal = 'center';
                                    }
                                    
                                    // Apply styling
                                    cell.style = {
                                        font: { size: 10 },
                                        alignment: alignment,
                                        border: borderStyle
                                    };
                                    
                                    // Alternate row coloring
                                    if (rowNumber % 2 === 0) {
                                        cell.style.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFF8F9FA' } };
                                    }
                                }
                            });
                        });
                        
                        // Add autofilter only (simpler and more reliable than tables)
                        if (cleanData.length > 1 && headers.length > 0) {
                            // Helper function to convert column number to Excel column letter
                            function columnToLetter(column) {
                                let temp, letter = '';
                                while (column > 0) {
                                    temp = (column - 1) % 26;
                                    letter = String.fromCharCode(temp + 65) + letter;
                                    column = (column - temp - 1) / 26;
                                }
                                return letter;
                            }
                            
                            const lastColumn = columnToLetter(headers.length);
                            const lastRow = cleanData.length;
                            
                            // Set autofilter range (just the header row)
                            worksheet.autoFilter = `A1:${lastColumn}${lastRow}`;
                        }
                    }
                });
                
                // Generate file buffer
                const excelBuffer = await workbook.xlsx.writeBuffer();
                
                // Create download blob
                const blob = new Blob([excelBuffer], { 
                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                });
                
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const fileName = `Active_Outages_${timestamp}.xlsx`;
                
                // Multiple download strategies for iframe compatibility
                const downloadSuccess = await downloadFileIframe(blob, fileName);
                
                setLoading(false);
                
                if (downloadSuccess) {
                    showToast('Export Complete', 
                        `Excel file exported with latest data and formatting`, 
                        'success', 4000);
                } else {
                    showToast('Export Notice', 
                        `File prepared. If download didn't start automatically, please check for a manual download option.`, 
                        'info', 6000);
                }
                
            } catch (error) {
                setLoading(false);
                showToast('Export Error', `Failed to export Excel file: ${error.message}`, 'error', 6000);
                console.error('Export error:', error);
            } finally {
                // Always reset the export flag
                isExporting = false;
            }
        }

        // Enhanced download function that works in iframe environments
        async function downloadFileIframe(blob, fileName) {
            try {
                console.log('Attempting download in iframe-safe mode...');
                
                // Check if we're in an iframe first
                const isInIframe = window !== window.top;
                console.log(`Environment: ${isInIframe ? 'iframe' : 'regular page'}`);
                
                // Strategy 1: Try the standard download approach first (only if not in iframe)
                if (!isInIframe) {
                    console.log('Trying standard download...');
                    if (await tryStandardDownload(blob, fileName)) {
                        console.log('✅ Standard download successful');
                        return true;
                    }
                    console.log('❌ Standard download failed');
                    // Small delay before next strategy
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Strategy 2: Try using data URL in new tab (works in most iframes)
                console.log('Trying data URL download...');
                if (await tryDataUrlDownload(blob, fileName)) {
                    console.log('✅ Data URL download successful');
                    return true;
                }
                console.log('❌ Data URL download failed');
                // Small delay before next strategy
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Strategy 3: Try opening in new window/tab with target="_blank"
                console.log('Trying new window download...');
                if (await tryNewWindowDownload(blob, fileName)) {
                    console.log('✅ New window download successful');
                    return true;
                }
                console.log('❌ New window download failed');
                
                // Strategy 4: Try posting message to parent (if same origin and in iframe)
                if (isInIframe) {
                    console.log('Trying parent window message...');
                    if (await tryParentWindowDownload(blob, fileName)) {
                        console.log('✅ Parent window download successful');
                        return true;
                    }
                    console.log('❌ Parent window message failed');
                }
                
                // Strategy 5: Last resort - show manual download link
                console.log('⚠️ Using manual download fallback');
                tryManualDownload(blob, fileName);
                return false;
                
            } catch (error) {
                console.error('All download strategies failed:', error);
                showToast('Download Error', 
                    `Unable to download file: ${error.message}`, 
                    'error', 8000);
                return false;
            }
        }

        // Strategy 1: Standard download (works in regular pages)
        async function tryStandardDownload(blob, fileName) {
            return new Promise((resolve) => {
                try {
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = fileName;
                    link.style.display = 'none';
                    
                    // Simple download attempt for non-iframe environments
                    document.body.appendChild(link);
                    
                    // Create and dispatch click event
                    const event = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: true
                    });
                    
                    const clicked = link.dispatchEvent(event);
                    
                    // Clean up immediately
                    setTimeout(() => {
                        if (link.parentNode) {
                            document.body.removeChild(link);
                        }
                        window.URL.revokeObjectURL(url);
                        
                        // In regular pages, if click was dispatched successfully, 
                        // assume download worked
                        resolve(clicked);
                    }, 50);
                    
                } catch (error) {
                    console.warn('Standard download failed:', error);
                    resolve(false);
                }
            });
        }

        // Strategy 2: Data URL in new tab (often works in iframes)
        async function tryDataUrlDownload(blob, fileName) {
            return new Promise((resolve) => {
                try {
                    // Only try data URL for smaller files (avoid browser memory issues)
                    if (blob.size > 50 * 1024 * 1024) { // 50MB limit
                        console.warn('File too large for data URL strategy');
                        resolve(false);
                        return;
                    }
                    
                    const reader = new FileReader();
                    
                    reader.onload = function() {
                        try {
                            const dataUrl = reader.result;
                            
                            // Try to open in new tab with download
                            const link = document.createElement('a');
                            link.href = dataUrl;
                            link.download = fileName;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            link.style.display = 'none';
                            
                            document.body.appendChild(link);
                            
                            // Create and dispatch click event
                            const clickEvent = new MouseEvent('click', {
                                view: window,
                                bubbles: true,
                                cancelable: true
                            });
                            
                            const success = link.dispatchEvent(clickEvent);
                            
                            setTimeout(() => {
                                if (link.parentNode) {
                                    document.body.removeChild(link);
                                }
                                // Wait a bit longer to see if download started
                                setTimeout(() => {
                                    resolve(success);
                                }, 200);
                            }, 100);
                            
                        } catch (error) {
                            console.warn('Data URL download failed:', error);
                            resolve(false);
                        }
                    };
                    
                    reader.onerror = () => {
                        console.warn('FileReader failed for data URL');
                        resolve(false);
                    };
                    
                    reader.readAsDataURL(blob);
                    
                } catch (error) {
                    console.warn('Data URL strategy failed:', error);
                    resolve(false);
                }
            });
        }

        // Strategy 3: Open in new window/tab
        async function tryNewWindowDownload(blob, fileName) {
            return new Promise((resolve) => {
                try {
                    const url = window.URL.createObjectURL(blob);
                    
                    // Create download URL with content-disposition hint
                    const downloadUrl = `${url}#download=${encodeURIComponent(fileName)}`;
                    
                    // Try to open in new window
                    const newWindow = window.open(
                        downloadUrl, 
                        '_blank',
                        'noopener,noreferrer,width=800,height=600,toolbar=yes,location=yes,directories=no,status=yes,menubar=yes,scrollbars=yes,resizable=yes'
                    );
                    
                    if (newWindow) {
                        // Set a timer to clean up the URL object
                        setTimeout(() => {
                            window.URL.revokeObjectURL(url);
                        }, 10000);
                        
                        resolve(true);
                    } else {
                        window.URL.revokeObjectURL(url);
                        resolve(false);
                    }
                    
                } catch (error) {
                    console.warn('New window download failed:', error);
                    resolve(false);
                }
            });
        }

        // Strategy 4: Post message to parent window (same origin only)
        async function tryParentWindowDownload(blob, fileName) {
            return new Promise((resolve) => {
                try {
                    if (window === window.top) {
                        resolve(false); // Not in iframe
                        return;
                    }
                    
                    // Convert blob to base64 for message passing
                    const reader = new FileReader();
                    
                    reader.onload = function() {
                        try {
                            const base64Data = reader.result.split(',')[1];
                            
                            // Send message to parent
                            window.parent.postMessage({
                                type: 'IFRAME_DOWNLOAD_REQUEST',
                                fileName: fileName,
                                data: base64Data,
                                mimeType: blob.type,
                                timestamp: Date.now()
                            }, '*');
                            
                            console.log('Download request sent to parent window');
                            
                            // Listen for response from parent
                            const messageHandler = (event) => {
                                if (event.data && event.data.type === 'IFRAME_DOWNLOAD_RESPONSE') {
                                    window.removeEventListener('message', messageHandler);
                                    resolve(event.data.success || false);
                                }
                            };
                            
                            window.addEventListener('message', messageHandler);
                            
                            // Timeout after 3 seconds
                            setTimeout(() => {
                                window.removeEventListener('message', messageHandler);
                                resolve(false);
                            }, 3000);
                            
                        } catch (error) {
                            console.warn('Parent message failed:', error);
                            resolve(false);
                        }
                    };
                    
                    reader.onerror = () => resolve(false);
                    reader.readAsDataURL(blob);
                    
                } catch (error) {
                    console.warn('Parent window strategy failed:', error);
                    resolve(false);
                }
            });
        }

        // Strategy 5: Manual download fallback
        function tryManualDownload(blob, fileName) {
            try {
                // Check if a download modal is already open
                if (document.querySelector('.download-overlay')) {
                    console.warn('Manual download modal already open');
                    return true;
                }
                
                const url = window.URL.createObjectURL(blob);
                
                // Create a modal-like overlay for manual download
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.7);
                    backdrop-filter: blur(5px);
                    z-index: 99999;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                `;
                
                const modal = document.createElement('div');
                modal.style.cssText = `
                    background: white;
                    border-radius: 20px;
                    padding: 40px;
                    box-shadow: 0 20px 40px rgba(31, 38, 135, 0.4);
                    max-width: 90%;
                    width: 400px;
                    text-align: center;
                    animation: modalSlideIn 0.3s ease-out;
                `;
                
                // Add CSS animation
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes modalSlideIn {
                        from {
                            opacity: 0;
                            transform: translateY(-20px) scale(0.95);
                        }
                        to {
                            opacity: 1;
                            transform: translateY(0) scale(1);
                        }
                    }
                `;
                document.head.appendChild(style);
                
                modal.innerHTML = `
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 48px; margin-bottom: 16px;">📥</div>
                        <h2 style="color: #667eea; margin: 0 0 12px 0; font-size: 24px;">Download Ready!</h2>
                        <p style="color: #6c757d; margin: 0 0 20px 0; line-height: 1.5;">
                            Your Excel file has been prepared. Due to iframe restrictions, 
                            please click the button below to download:
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 24px;">
                        <a href="${url}" download="${fileName}" target="_blank" rel="noopener noreferrer"
                           style="display: inline-block; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                                  color: white; padding: 16px 32px; text-decoration: none; 
                                  border-radius: 12px; font-weight: 600; font-size: 16px;
                                  box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
                                  transition: all 0.3s ease; border: none; cursor: pointer;">
                            <span style="margin-right: 8px;">💾</span>
                            Download ${fileName}
                        </a>
                    </div>
                    
                    <div style="border-top: 1px solid #e9ecef; padding-top: 20px; margin-top: 20px;">
                        <p style="color: #8b949e; font-size: 14px; margin: 0 0 12px 0;">
                            💡 <strong>Tip:</strong> If the download doesn't start, try right-clicking the button and selecting "Save link as..."
                        </p>
                        <button onclick="this.closest('.download-overlay').remove(); window.URL.revokeObjectURL('${url}')" 
                                style="background: transparent; color: #6c757d; border: 1px solid #dee2e6; 
                                       padding: 8px 20px; border-radius: 8px; cursor: pointer; font-size: 14px;
                                       transition: all 0.2s ease;">
                            Close
                        </button>
                    </div>
                `;
                
                overlay.className = 'download-overlay';
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                // Close on overlay click
                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        overlay.remove();
                        window.URL.revokeObjectURL(url);
                    }
                });
                
                // Auto-remove after 2 minutes
                setTimeout(() => {
                    if (overlay.parentElement) {
                        overlay.remove();
                        window.URL.revokeObjectURL(url);
                    }
                }, 120000);
                
                return true;
                
            } catch (error) {
                console.error('Manual download fallback failed:', error);
                return false;
            }
        }

        // Listen for parent window download handler (optional)
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'IFRAME_DOWNLOAD_REQUEST') {
                try {
                    // If parent window has a download handler, it can process this
                    const { fileName, data, mimeType } = event.data;
                    
                    // Convert base64 back to blob
                    const byteCharacters = atob(data);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    const blob = new Blob([byteArray], { type: mimeType });
                    
                    // Try standard download in parent context
                    const url = window.URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = fileName;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    window.URL.revokeObjectURL(url);
                    
                    // Send success response
                    event.source.postMessage({
                        type: 'IFRAME_DOWNLOAD_RESPONSE',
                        success: true
                    }, event.origin);
                    
                } catch (error) {
                    console.error('Parent download handler failed:', error);
                    // Send failure response
                    event.source.postMessage({
                        type: 'IFRAME_DOWNLOAD_RESPONSE',
                        success: false
                    }, event.origin);
                }
            }
        });

        function formatDateTime(textarea) {
            const value = textarea.value.trim();
            
            // Handle empty value - clear corresponding duration field
            if (!value) {
                // Check if this is a PCM Created AT field and clear duration
                if (textarea.closest('td').cellIndex !== undefined) {
                    const row = textarea.closest('tr');
                    const cells = row.querySelectorAll('td');
                    const headers = Array.from(row.closest('table').querySelectorAll('th')).map(th => th.textContent);
                    
                    // Find PCM Created and Elapsed Duration columns
                    const pcmCreatedCol = headers.findIndex(h => h.toLowerCase().includes('pcm created'));
                    const elapsedDurationCol = headers.findIndex(h => h.toLowerCase().includes('elapsed duration'));
                    
                    if (pcmCreatedCol >= 0 && elapsedDurationCol >= 0 && 
                        textarea.closest('td').cellIndex === pcmCreatedCol) {
                        // Clear the duration field
                        const durationTextarea = cells[elapsedDurationCol].querySelector('textarea');
                        if (durationTextarea) {
                            durationTextarea.value = '';
                            durationTextarea.dataset.rawHours = '';
                            durationTextarea.classList.remove('elapsed-duration-live');
                            markAsModified();
                        }
                    }
                }
                return;
            }
            
            try {
                let dateObj = null;
                
                // Handle AM/PM time formats
                function parseTimeWithAMPM(timeStr) {
                    const ampmMatch = timeStr.match(/(\d{1,2}):(\d{1,2}):?(\d{1,2})?\s*(AM|PM)/i);
                    if (ampmMatch) {
                        let hours = parseInt(ampmMatch[1]);
                        const minutes = parseInt(ampmMatch[2]);
                        const seconds = parseInt(ampmMatch[3] || '0');
                        const ampm = ampmMatch[4].toUpperCase();
                        
                        // Convert to 24-hour format
                        if (ampm === 'PM' && hours !== 12) {
                            hours += 12;
                        } else if (ampm === 'AM' && hours === 12) {
                            hours = 0;
                        }
                        
                        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                    return null;
                }
                
                // Handle various input formats
                if (/\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4}/.test(value)) {
                    // MM/DD/YYYY, DD/MM/YYYY with optional time (including AM/PM)
                    // Split by date separators first to get the date part
                    const mainParts = value.split(/\s+/);
                    const datePart = mainParts[0];
                    const timePart = mainParts.slice(1).join(' ');
                    
                    console.log(`Parsing: "${value}" -> datePart: "${datePart}", timePart: "${timePart}"`);
                    
                    // Parse the date part
                    const dateParts = datePart.split(/[\/\-\.]/);
                    if (dateParts.length === 3) {
                        let part1 = parseInt(dateParts[0]); // First number
                        let part2 = parseInt(dateParts[1]); // Second number  
                        let year = parseInt(dateParts[2]);  // Year
                        
                        console.log(`Date parts: part1=${part1}, part2=${part2}, year=${year}`);
                        
                        // Handle 2-digit years
                        if (year < 100) {
                            if (year < 50) {
                                year = 2000 + year;
                            } else {
                                year = 1900 + year;
                            }
                        }
                        
                        // Handle time part (including AM/PM)
                        let formattedTime = '00:00:00';
                        if (timePart) {
                            const ampmTime = parseTimeWithAMPM(timePart);
                            if (ampmTime) {
                                formattedTime = ampmTime;
                            } else {
                                // Regular time format without AM/PM
                                const timeMatch = timePart.match(/(\d{1,2}):(\d{1,2}):?(\d{1,2})?/);
                                if (timeMatch) {
                                    const hours = parseInt(timeMatch[1]).toString().padStart(2, '0');
                                    const minutes = parseInt(timeMatch[2]).toString().padStart(2, '0');
                                    const seconds = parseInt(timeMatch[3] || '0').toString().padStart(2, '0');
                                    formattedTime = `${hours}:${minutes}:${seconds}`;
                                }
                            }
                        }
                        
                        console.log(`Formatted time: ${formattedTime}`);
                        
                        // Determine if it's MM/DD/YYYY or DD/MM/YYYY format
                        let month, day;
                        
                        if (part1 > 12 && part2 <= 12) {
                            // Must be DD/MM/YYYY format (day > 12, month <= 12)
                            day = part1;
                            month = part2;
                            console.log(`Detected DD/MM/YYYY: day=${day}, month=${month}`);
                        } else if (part2 > 12 && part1 <= 12) {
                            // Must be MM/DD/YYYY format (month <= 12, day > 12)
                            month = part1;
                            day = part2;
                            console.log(`Detected MM/DD/YYYY: month=${month}, day=${day}`);
                        } else if (part1 <= 12 && part2 <= 12) {
                            // Ambiguous case - use MM/DD/YYYY as default (US format)
                            month = part1;
                            day = part2;
                            console.log(`Ambiguous, defaulting to MM/DD/YYYY: month=${month}, day=${day}`);
                        } else {
                            // Both > 12, invalid
                            throw new Error('Invalid date: both month and day > 12');
                        }
                        
                        // Validate ranges
                        if (month < 1 || month > 12 || day < 1 || day > 31) {
                            throw new Error(`Invalid date ranges: month=${month}, day=${day}`);
                        }
                        
                        // Construct the date string
                        const dateString = `${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}T${formattedTime}`;
                        console.log(`Constructing date: "${dateString}"`);
                        
                        dateObj = new Date(dateString);
                        
                        // Verify the date was constructed correctly
                        if (isNaN(dateObj.getTime())) {
                            throw new Error(`Invalid date object from: ${dateString}`);
                        }
                        
                        console.log(`Successfully created date object: ${dateObj.toISOString()}`);
                    }
                } else if (/^\d{4}[\/\-\.]\d{1,2}[\/\-\.]\d{1,2}/.test(value)) {
                    // YYYY/MM/DD format with optional time
                    const dateTimeMatch = value.match(/(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})(?:\s+(.+))?/);
                    if (dateTimeMatch) {
                        const year = parseInt(dateTimeMatch[1]);
                        const month = parseInt(dateTimeMatch[2]);
                        const day = parseInt(dateTimeMatch[3]);
                        const timeStr = dateTimeMatch[4] || '';
                        
                        let formattedTime = '00:00:00';
                        if (timeStr) {
                            const ampmTime = parseTimeWithAMPM(timeStr);
                            if (ampmTime) {
                                formattedTime = ampmTime;
                            } else {
                                const timeMatch = timeStr.match(/(\d{1,2}):(\d{1,2}):?(\d{1,2})?/);
                                if (timeMatch) {
                                    const hours = parseInt(timeMatch[1]).toString().padStart(2, '0');
                                    const minutes = parseInt(timeMatch[2]).toString().padStart(2, '0');
                                    const seconds = parseInt(timeMatch[3] || '0').toString().padStart(2, '0');
                                    formattedTime = `${hours}:${minutes}:${seconds}`;
                                }
                            }
                        }
                        
                        dateObj = new Date(`${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}T${formattedTime}`);
                    }
                } else if (/^\d{1,2}:\d{1,2}/.test(value) || /\d{1,2}:\d{1,2}.*[AP]M/i.test(value)) {
                    // Time only format (with or without AM/PM) - use today's date
                    const today = new Date();
                    let formattedTime = '00:00:00';
                    
                    const ampmTime = parseTimeWithAMPM(value);
                    if (ampmTime) {
                        formattedTime = ampmTime;
                    } else {
                        const timeMatch = value.match(/(\d{1,2}):(\d{1,2}):?(\d{1,2})?/);
                        if (timeMatch) {
                            const hours = parseInt(timeMatch[1]).toString().padStart(2, '0');
                            const minutes = parseInt(timeMatch[2]).toString().padStart(2, '0');
                            const seconds = parseInt(timeMatch[3] || '0').toString().padStart(2, '0');
                            formattedTime = `${hours}:${minutes}:${seconds}`;
                        }
                    }
                    
                    dateObj = new Date(`${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}T${formattedTime}`);
                } else if (/^\d{8}/.test(value)) {
                    // YYYYMMDD format
                    const year = parseInt(value.substring(0, 4));
                    const month = parseInt(value.substring(4, 6));
                    const day = parseInt(value.substring(6, 8));
                    let timeStr = '00:00:00';
                    
                    if (value.length > 8) {
                        const remainingStr = value.substring(8).trim();
                        const ampmTime = parseTimeWithAMPM(remainingStr);
                        if (ampmTime) {
                            timeStr = ampmTime;
                        } else {
                            const timeMatch = remainingStr.match(/(\d{1,2}):?(\d{1,2}):?(\d{1,2})?/);
                            if (timeMatch) {
                                const hours = parseInt(timeMatch[1] || '0').toString().padStart(2, '0');
                                const minutes = parseInt(timeMatch[2] || '0').toString().padStart(2, '0');
                                const seconds = parseInt(timeMatch[3] || '0').toString().padStart(2, '0');
                                timeStr = `${hours}:${minutes}:${seconds}`;
                            }
                        }
                    }
                    
                    dateObj = new Date(`${year}-${month.toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}T${timeStr}`);
                } else {
                    // Try standard JavaScript parsing
                    dateObj = new Date(value);
                    
                    // If still invalid, try parsing as "now" for current timestamp
                    if (isNaN(dateObj.getTime()) && (value.toLowerCase() === 'now' || value.toLowerCase() === 'today')) {
                        dateObj = new Date();
                    }
                }
                
                // Check if date is valid
                if (!isNaN(dateObj.getTime())) {
                    // Format as yyyy-mm-dd hh:mm:ss
                    const year = dateObj.getFullYear();
                    const month = String(dateObj.getMonth() + 1).padStart(2, '0');
                    const day = String(dateObj.getDate()).padStart(2, '0');
                    const hours = String(dateObj.getHours()).padStart(2, '0');
                    const minutes = String(dateObj.getMinutes()).padStart(2, '0');
                    const seconds = String(dateObj.getSeconds()).padStart(2, '0');
                    
                    const formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
                    
                    console.log(`Final formatted date: "${formattedDate}"`);
                    
                    // Only update if different to avoid cursor jumping
                    if (textarea.value !== formattedDate) {
                        textarea.value = formattedDate;
                        
                        // Add visual feedback
                        textarea.classList.add('auto-filled');
                        setTimeout(() => {
                            textarea.classList.remove('auto-filled');
                            textarea.classList.add('date-time-field'); // Restore original styling
                        }, 1000);
                    }
                    
                    // Calculate duration if this is PCM Created
                    if (textarea.closest('td').cellIndex !== undefined) {
                        const row = textarea.closest('tr');
                        const cells = row.querySelectorAll('td');
                        const headers = Array.from(row.closest('table').querySelectorAll('th')).map(th => th.textContent);
                        
                        // Find PCM Created and Elapsed Duration columns
                        const pcmCreatedCol = headers.findIndex(h => h.toLowerCase().includes('pcm created'));
                        const elapsedDurationCol = headers.findIndex(h => h.toLowerCase().includes('elapsed duration'));
                        
                        if (pcmCreatedCol >= 0 && elapsedDurationCol >= 0 && 
                            textarea.closest('td').cellIndex === pcmCreatedCol) {
                            // Calculate and update duration - Excel style
                            const durationTextarea = cells[elapsedDurationCol].querySelector('textarea');
                            if (durationTextarea) {
                                const now = new Date();
                                
                                // Calculate time difference exactly like Excel
                                const MS_PER_SECOND = 1000;
                                const MS_PER_MINUTE = 60 * MS_PER_SECOND;
                                const MS_PER_HOUR = 60 * MS_PER_MINUTE;
                                
                                const msDiff = now - dateObj;
                                
                                const totalHours = Math.floor(msDiff / MS_PER_HOUR);
                                const remainingMs = msDiff % MS_PER_HOUR;
                                const totalMinutes = Math.floor(remainingMs / MS_PER_MINUTE);
                                const totalSeconds = Math.floor((remainingMs % MS_PER_MINUTE) / MS_PER_SECOND);
                                
                                const durationHours = totalHours + (totalMinutes / 60) + (totalSeconds / 3600);
                                
                                durationTextarea.dataset.rawHours = durationHours;
                                durationTextarea.value = durationHours.toString();
                                formatDuration(durationTextarea);
                                markAsModified();
                            }
                        }
                    }
                } else {
                    // Show error for invalid date
                    textarea.style.borderColor = '#dc3545';
                    textarea.style.borderWidth = '2px';
                    setTimeout(() => {
                        textarea.style.borderColor = '';
                        textarea.style.borderWidth = '';
                        textarea.classList.add('date-time-field'); // Restore original styling
                    }, 2000);
                    console.log(`Failed to parse date: "${value}"`);
                    // Invalid date notification removed
                }
            } catch (e) {
                console.error('Error formatting date:', e);
                textarea.style.borderColor = '#dc3545';
                textarea.style.borderWidth = '2px';
                setTimeout(() => {
                    textarea.style.borderColor = '';
                    textarea.style.borderWidth = '';
                    textarea.classList.add('date-time-field');
                }, 2000);
                // Date error notification removed
            }
        }

        // Show date format help on first focus
        function showDateFormatHelp(textarea) {
            if (!textarea.hasShownHelp) {
                textarea.hasShownHelp = true;
                // Date format help notification removed
            }
        }
        // Format duration input to [h]:mm:ss format - Exactly like Excel
        function formatDuration(textarea) {
            const value = textarea.value.trim();
            if (!value) return;
            
            try {
                // If already in [h]:mm:ss format, don't format again
                if (value.includes(':') && /^\d+:\d{2}:\d{2}$/.test(value)) {
                    return;
                }
                
                // Get hours value - use raw value from dataset if available for better precision
                let hours = textarea.dataset.rawHours ? parseFloat(textarea.dataset.rawHours) : parseFloat(value);
                if (isNaN(hours)) return;
                
                // Calculate with Excel-precision
                // Calculate total hours (integer part)
                const totalHours = Math.floor(hours);
                
                // Calculate total minutes from decimal part
                const decimalHours = hours - totalHours;
                const minutesDecimal = decimalHours * 60;
                const minutes = Math.floor(minutesDecimal);
                
                // Calculate seconds with extra precision
                const secondsDecimal = (minutesDecimal - minutes) * 60;
                // Round to nearest second to exactly match Excel
                const seconds = Math.round(secondsDecimal);
                
                // Handle overflow with proper cascading
                let adjustedHours = totalHours;
                let adjustedMinutes = minutes;
                let adjustedSeconds = seconds;
                
                if (adjustedSeconds === 60) {
                    adjustedSeconds = 0;
                    adjustedMinutes++;
                    
                    if (adjustedMinutes === 60) {
                        adjustedMinutes = 0;
                        adjustedHours++;
                    }
                }
                
                // Format with padded minutes and seconds
                const formattedMinutes = String(adjustedMinutes).padStart(2, '0');
                const formattedSeconds = String(adjustedSeconds).padStart(2, '0');
                
                // Set the visual formatted value
                textarea.value = `${adjustedHours}:${formattedMinutes}:${formattedSeconds}`;
            } catch (e) {
                console.error('Error formatting duration:', e);
            }
        }
        
        // Format all duration cells in all sheets
        function formatAllDurationCells() {
            Object.keys(workbookData).forEach(sheetName => {
                const table = document.querySelector(`#tab-${sheetName} table`);
                if (!table) return;
                
                const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent);
                const durationColIndex = headers.findIndex(h => h.toLowerCase().includes('elapsed duration'));
                const pcmCreatedColIndex = headers.findIndex(h => h.toLowerCase().includes('pcm created'));
                
                if (durationColIndex >= 0 && pcmCreatedColIndex >= 0) {
                    const rows = table.querySelectorAll('tbody tr');
                    rows.forEach((row, rowIndex) => {
                        const pcmCell = row.querySelectorAll('td')[pcmCreatedColIndex];
                        const durationCell = row.querySelectorAll('td')[durationColIndex];
                        
                        if (pcmCell && durationCell) {
                            const pcmTextarea = pcmCell.querySelector('textarea');
                            const durationTextarea = durationCell.querySelector('textarea');
                            
                            if (pcmTextarea && durationTextarea && pcmTextarea.value) {
                                // Recalculate duration from PCM date for accuracy
                                try {
                                    const pcmDate = new Date(pcmTextarea.value);
                                    if (!isNaN(pcmDate.getTime())) {
                                        const now = new Date();
                                        
                                        // Calculate time difference exactly like Excel
                                        const MS_PER_SECOND = 1000;
                                        const MS_PER_MINUTE = 60 * MS_PER_SECOND;
                                        const MS_PER_HOUR = 60 * MS_PER_MINUTE;
                                        
                                        // Get total milliseconds difference
                                        const msDiff = now - pcmDate;
                                        
                                        // Calculate hours, minutes, seconds precisely 
                                        const totalHours = Math.floor(msDiff / MS_PER_HOUR);
                                        const remainingMs = msDiff % MS_PER_HOUR;
                                        const totalMinutes = Math.floor(remainingMs / MS_PER_MINUTE);
                                        const totalSeconds = Math.floor((remainingMs % MS_PER_MINUTE) / MS_PER_SECOND);
                                        
                                        // Store exact values for formatting
                                        const durationHours = totalHours + (totalMinutes / 60) + (totalSeconds / 3600);
                                        durationTextarea.dataset.rawHours = durationHours;
                                        
                                        // Format directly rather than setting raw value first
                                        const formattedHours = totalHours;
                                        const formattedMinutes = String(totalMinutes).padStart(2, '0');
                                        const formattedSeconds = String(totalSeconds).padStart(2, '0');
                                        durationTextarea.value = `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
                                    } else if (durationTextarea.value) {
                                        // If date is invalid but duration has a value, just format it
                                        formatDuration(durationTextarea);
                                    }
                                } catch (e) {
                                    console.error('Error calculating duration:', e);
                                    // Fallback to simple formatting
                                    if (durationTextarea.value) {
                                        formatDuration(durationTextarea);
                                    }
                                }
                            } else if (durationTextarea && !pcmTextarea.value) {
                                // Clear duration if PCM Created At is empty
                                durationTextarea.value = '';
                                durationTextarea.classList.remove('elapsed-duration-live');
                            } else if (durationTextarea && durationTextarea.value) {
                                // Just format existing duration values
                                formatDuration(durationTextarea);
                            }
                        }
                    });
                }
            });
        }
        
        // Function to redistribute table width to eliminate free space
        function redistributeTableWidth(table, sheetName) {
            const headers = table.querySelectorAll('thead th');
            if (headers.length === 0) return;
            
            const tableWidth = table.offsetWidth;
            let totalUsedWidth = 0;
            
            // Calculate total width used by all columns except the last one
            for (let i = 0; i < headers.length - 1; i++) {
                totalUsedWidth += headers[i].offsetWidth;
            }
            
            // Calculate remaining width for the last column
            const lastColumnIndex = headers.length - 1;
            const lastHeader = headers[lastColumnIndex];
            const remainingWidth = Math.max(tableWidth - totalUsedWidth, 50); // Minimum 50px
            
            // Apply the remaining width to the last column
            lastHeader.style.width = `${remainingWidth}px`;
            lastHeader.style.minWidth = `${remainingWidth}px`;
            columnWidths[sheetName][lastColumnIndex] = `${remainingWidth}px`;
        }

        // Global resize functions for reuse across table setup and row addition
        let resizeState = {
            currentRow: null,
            currentHeader: null,
            startX: 0,
            startY: 0,
            startWidth: 0,
            startHeight: 0,
            currentSheet: null,
            rowIndex: 0
        };

        function handleColumnResize(e) {
            if (!resizeState.currentHeader) return;
            
            const width = resizeState.startWidth + (e.clientX - resizeState.startX);
            const minWidth = 50;
            
            if (width >= minWidth) {
                resizeState.currentHeader.style.width = `${width}px`;
                resizeState.currentHeader.style.minWidth = `${width}px`;
                const headerIndex = Array.from(resizeState.currentHeader.parentNode.children).indexOf(resizeState.currentHeader);
                columnWidths[resizeState.currentSheet][headerIndex] = `${width}px`;
                
                // Auto-adjust last column to fill remaining space
                const table = resizeState.currentHeader.closest('table');
                redistributeTableWidth(table, resizeState.currentSheet);
                markAsModified();
            }
        }
        
        function stopColumnResize() {
            document.body.style.cursor = '';
            if (resizeState.currentHeader) {
                resizeState.currentHeader.classList.remove('resizing');
                const resizeHandle = resizeState.currentHeader.querySelector('.resize-handle');
                if (resizeHandle) resizeHandle.classList.remove('active');
                
                // Final adjustment to ensure table fills full width
                const table = resizeState.currentHeader.closest('table');
                redistributeTableWidth(table, resizeState.currentSheet);
                resizeState.currentHeader = null;
            }
            
            document.removeEventListener('mousemove', handleColumnResize);
            document.removeEventListener('mouseup', stopColumnResize);
        }

        function handleHeaderResize(e) {
            const height = resizeState.startHeight + (e.clientY - resizeState.startY);
            const minHeight = 25;
            
            if (height >= minHeight) {
                // Apply to all headers in the row
                const headers = resizeState.currentHeader.closest('tr').querySelectorAll('th');
                headers.forEach(header => {
                    header.style.height = `${height}px`;
                });
                headerHeight[resizeState.currentSheet][0] = `${height}px`;
                markAsModified();
            }
        }
        
        function stopHeaderResize() {
            document.body.style.cursor = '';
            if (resizeState.currentHeader) {
                resizeState.currentHeader.classList.remove('resizing-header');
                const headerResizeHandle = resizeState.currentHeader.querySelector('.header-resize-handle');
                if (headerResizeHandle) headerResizeHandle.classList.remove('active');
                resizeState.currentHeader = null;
            }
            
            document.removeEventListener('mousemove', handleHeaderResize);
            document.removeEventListener('mouseup', stopHeaderResize);
        }

        function handleRowResize(e) {
            if (!resizeState.currentRow) return;
            
            const height = resizeState.startHeight + (e.clientY - resizeState.startY);
            const minHeight = 28; // Match default row height
            
            if (height >= minHeight) {
                resizeState.currentRow.style.height = `${height}px`;
                
                // Update all textareas in this row to match the new height
                const textareas = resizeState.currentRow.querySelectorAll('textarea.editable');
                textareas.forEach(textarea => {
                    textarea.style.height = `${height - 8}px`; // Account for cell padding
                });
                
                // Update fault level inputs in this row to match the new height
                const faultLevelInputs = resizeState.currentRow.querySelectorAll('.fault-level-input');
                faultLevelInputs.forEach(input => {
                    input.style.height = `${height - 8}px`; // Account for cell padding
                    input.style.lineHeight = `${height - 8}px`; // Center text vertically
                });
                
                if (!rowHeights[resizeState.currentSheet]) {
                    rowHeights[resizeState.currentSheet] = {};
                }
                rowHeights[resizeState.currentSheet][resizeState.rowIndex] = `${height}px`;
                markAsModified();
            }
        }
        
        function stopRowResize() {
            document.body.style.cursor = '';
            if (resizeState.currentRow) {
                resizeState.currentRow.classList.remove('resizing');
                const rowResizeHandle = resizeState.currentRow.querySelector('.row-resize-handle');
                if (rowResizeHandle) rowResizeHandle.classList.remove('active');
                resizeState.currentRow = null;
            }
            
            document.removeEventListener('mousemove', handleRowResize);
            document.removeEventListener('mouseup', stopRowResize);
        }

        // Setup table resizing functionality
        function setupTableResizing(tableContainer, sheetName) {
            const table = tableContainer.querySelector('table');
            if (!table) return;
            
            // Initialize states
            if (!columnWidths[sheetName]) columnWidths[sheetName] = {};
            if (!rowHeights[sheetName]) rowHeights[sheetName] = {};
            if (!headerHeight[sheetName]) headerHeight[sheetName] = {};
            
            // Add column resize handles to all table headers
            const headers = table.querySelectorAll('thead th');
            headers.forEach((th, index) => {
                // Create column resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                resizeHandle.title = 'Drag to resize column width';
                th.appendChild(resizeHandle);
                
                // Create header row resize handle
                const headerResizeHandle = document.createElement('div');
                headerResizeHandle.className = 'header-resize-handle';
                headerResizeHandle.title = 'Drag to resize header height';
                th.appendChild(headerResizeHandle);
                
                // Apply saved widths
                if (columnWidths[sheetName][index]) {
                    th.style.width = columnWidths[sheetName][index];
                    th.style.minWidth = columnWidths[sheetName][index];
                }
                
                // Apply saved header height
                if (headerHeight[sheetName] && Object.keys(headerHeight[sheetName]).length > 0) {
                    th.style.height = headerHeight[sheetName][0] || 'auto';
                }
                
                // Column resize functionality using global functions
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizeState.startX = e.clientX;
                    resizeState.currentHeader = th;
                    resizeState.startWidth = th.offsetWidth;
                    resizeState.currentSheet = sheetName;
                    
                    document.body.style.cursor = 'col-resize';
                    th.classList.add('resizing');
                    resizeHandle.classList.add('active');
                    
                    document.addEventListener('mousemove', handleColumnResize);
                    document.addEventListener('mouseup', stopColumnResize);
                });
                
                // Header row resize functionality using global functions
                headerResizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizeState.startY = e.clientY;
                    resizeState.startHeight = th.offsetHeight;
                    resizeState.currentHeader = th;
                    resizeState.currentSheet = sheetName;
                    
                    document.body.style.cursor = 'row-resize';
                    th.classList.add('resizing-header');
                    headerResizeHandle.classList.add('active');
                    
                    document.addEventListener('mousemove', handleHeaderResize);
                    document.addEventListener('mouseup', stopHeaderResize);
                });
            });
            
            // Add row resize handles to all table rows
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach((tr, index) => {
                // Create row resize handle
                const rowResizeHandle = document.createElement('div');
                rowResizeHandle.className = 'row-resize-handle';
                rowResizeHandle.title = 'Drag to resize row height';
                tr.appendChild(rowResizeHandle);
                
                // Apply saved height
                if (rowHeights[sheetName][index]) {
                    const savedHeight = parseInt(rowHeights[sheetName][index]);
                    tr.style.height = `${savedHeight}px`;
                    
                    // Update all textareas in this row to match the saved height
                    const textareas = tr.querySelectorAll('textarea.editable');
                    textareas.forEach(textarea => {
                        textarea.style.height = `${savedHeight - 8}px`; // Account for cell padding
                    });
                    
                    // Update fault level inputs in this row to match the saved height
                    const faultLevelInputs = tr.querySelectorAll('.fault-level-input');
                    faultLevelInputs.forEach(input => {
                        input.style.height = `${savedHeight - 8}px`; // Account for cell padding
                        input.style.lineHeight = `${savedHeight - 8}px`; // Center text vertically
                    });
                }
                
                // Row resize functionality using global functions
                rowResizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizeState.startY = e.clientY;
                    resizeState.currentRow = tr;
                    resizeState.startHeight = tr.offsetHeight;
                    resizeState.currentSheet = sheetName;
                    resizeState.rowIndex = index;
                    
                    document.body.style.cursor = 'row-resize';
                    tr.classList.add('resizing');
                    rowResizeHandle.classList.add('active');
                    
                    document.addEventListener('mousemove', handleRowResize);
                    document.addEventListener('mouseup', stopRowResize);
                });
            });
        }

        // Event listeners
        elements.downloadBtn.addEventListener('click', () => downloadFromGitHub(true));
        elements.saveBtn.addEventListener('click', saveToGitHub);
        elements.exportBtn.addEventListener('click', exportExcelFile);
        elements.autoFillBtn.addEventListener('click', autoFillColumns);
        elements.refreshTokenBtn.addEventListener('click', async () => {
            setLoading(true);
            
            // Add debug info
            console.log('=== TOKEN REFRESH DEBUG INFO ===');
            console.log('Current time:', new Date().toISOString());
            console.log('Config encoding key:', CONFIG.encodingKey);
            console.log('Fallback token available:', !!CONFIG.fallbackToken);
            
            const success = await loadApiTokenFromRemote();
            if (success) {
                showToast('Success', 'API token refreshed successfully', 'success', 3000);
            }
            setLoading(false);
        });
        elements.refreshLookupBtn.addEventListener('click', () => refreshLookupData(true));
        elements.addRowBtn.addEventListener('click', addRow);
        elements.deleteRowBtn.addEventListener('click', deleteRow);
        elements.autoFitWidthBtn.addEventListener('click', autoFitColumnWidths);
        elements.autoFitHeightBtn.addEventListener('click', autoFitRowHeights);
        elements.saveFormatBtn.addEventListener('click', saveFormat);
        elements.resetDefaultBtn.addEventListener('click', resetToDefault);
        elements.autoRefreshSettingsBtn.addEventListener('click', showAutoRefreshSettings);
        elements.collaborationSettingsBtn.addEventListener('click', showCollaborationSettings);
        
        // Dropdown controls for main buttons
        elements.tableStyleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleDropdown(elements.tableStyleDropdown);
        });
        
        elements.databaseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleDropdown(elements.databaseDropdown);
        });
        
        elements.editRowBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleDropdown(elements.editRowDropdown);
        });
        
        elements.formatBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleDropdown(elements.formatDropdown);
        });
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', () => {
            closeAllDropdowns();
        });
        
        // Prevent dropdowns from closing when clicking inside
        elements.tableStyleDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        elements.databaseDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        elements.editRowDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        elements.formatDropdown.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Styling control event listeners
        elements.textSizeSelect.addEventListener('change', () => {
            updateTableTextSize();
            showToast('Text Size Changed', `Table: ${elements.textSizeSelect.value}`, 'success', 2000);
        });
        elements.headerSizeSelect.addEventListener('change', () => {
            updateHeaderTextSize();
            showToast('Header Size Changed', `Header: ${elements.headerSizeSelect.value}`, 'success', 2000);
        });
        elements.textColorPicker.addEventListener('change', () => {
            updateTextColor();
            showToast('Text Color Changed', 'Table text color updated', 'success', 2000);
        });
        elements.headerTextColorPicker.addEventListener('change', () => {
            updateHeaderTextColor();
            showToast('Header Text Changed', 'Header text color updated', 'success', 2000);
        });
        elements.headerColorPicker.addEventListener('change', () => {
            updateHeaderColor();
            showToast('Header Background Changed', 'Header background updated', 'success', 2000);
        });
        elements.tableColorPicker.addEventListener('change', () => {
            updateTableColor();
            showToast('Table Background Changed', 'Table background updated', 'success', 2000);
        });

        // Dropdown control functions
        function toggleDropdown(dropdown) {
            const isVisible = dropdown.classList.contains('show');
            closeAllDropdowns();
            if (!isVisible) {
                dropdown.classList.add('show');
            }
        }
        
        function closeAllDropdowns() {
            document.querySelectorAll('.dropdown-menu').forEach(dropdown => {
                dropdown.classList.remove('show');
            });
        }
        function setLoading(loading, message = '') {
            elements.progressBar.style.display = loading ? 'block' : 'none';
            elements.loadingSpinner.style.display = loading ? 'block' : 'none';
            
            // Disable/enable buttons (including new dropdown buttons)
            const buttons = [elements.downloadBtn, elements.saveBtn, elements.exportBtn, 
                           elements.databaseBtn, elements.editRowBtn, elements.formatBtn, 
                           elements.tableStyleBtn, elements.autoFillBtn, elements.refreshTokenBtn,
                           elements.refreshLookupBtn, elements.addRowBtn, elements.deleteRowBtn, 
                           elements.autoFitWidthBtn, elements.autoFitHeightBtn, elements.saveFormatBtn, 
                           elements.resetDefaultBtn];
            buttons.forEach(btn => {
                if (btn) btn.disabled = loading;
            });
            
            // Don't update status at all - preserve Live Updates indicator
        }

        function updateStatus(message) {
            elements.statusText.textContent = message;
        }

        // Toast Notification System
        function showToast(title, message, type = 'info', duration = 5000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '✅',
                error: '❌',
                warning: '⚠️',
                info: 'ℹ️'
            };
            
            toast.innerHTML = `
                <div class="toast-header">
                    <div class="toast-title">
                        <span>${icons[type] || icons.info}</span>
                        ${title}
                    </div>
                    <button class="toast-close">&times;</button>
                </div>
                <div class="toast-message">${message}</div>
                <div class="toast-progress">
                    <div class="toast-progress-bar" style="animation-duration: ${duration}ms;"></div>
                </div>
            `;
            
            elements.toastContainer.appendChild(toast);
            
            // Show toast with animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Close functionality
            const closeBtn = toast.querySelector('.toast-close');
            const closeToast = () => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            };
            
            closeBtn.addEventListener('click', closeToast);
            
            // Auto close
            if (duration > 0) {
                setTimeout(closeToast, duration);
            }
            
            return toast;
        }

        function askConfirmation(title, message) {
            return new Promise((resolve) => {
                const toast = document.createElement('div');
                toast.className = 'toast warning';
                
                toast.innerHTML = `
                    <div class="toast-header">
                        <div class="toast-title">
                            <span>❓</span>
                            ${title}
                        </div>
                    </div>
                    <div class="toast-message">${message}</div>
                    <div style="margin-top: 12px; display: flex; gap: 8px; justify-content: flex-end;">
                        <button class="btn" style="padding: 6px 12px; font-size: 12px;" data-action="yes">Yes</button>
                        <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;" data-action="no">No</button>
                    </div>
                `;
                
                elements.toastContainer.appendChild(toast);
                setTimeout(() => toast.classList.add('show'), 10);
                
                const handleClick = (e) => {
                    const action = e.target.getAttribute('data-action');
                    if (action) {
                        toast.classList.remove('show');
                        setTimeout(() => {
                            if (toast.parentNode) {
                                toast.parentNode.removeChild(toast);
                            }
                        }, 300);
                        resolve(action === 'yes');
                    }
                };
                
                toast.addEventListener('click', handleClick);
            });
        }

        // Modal-like function using toasts for confirmation
        function showModal(title, message, showButtons = false) {
            return new Promise((resolve) => {
                if (showButtons) {
                    askConfirmation(title, message).then(resolve);
                } else {
                    showToast(title, message, 'info', 5000);
                    resolve(true);
                }
            });
        }

        function markAsModified() {
            isModified = true;
            document.title = "Excel Collaborator - Active Outages *";
        }

        // Optimized input handling with debouncing
        const debouncedMarkModified = debounce(markAsModified, 100);
        const debouncedLookup = debounce((input, sheetName) => {
            performRealTimeLookup(input, sheetName);
        }, 300);

        // Excel file handling with multiple source fallback
        async function downloadFromGitHub(showSuccessToast = true) {
            setLoading(true);
            
            let lastError = null;
            
            // Try each download source in order
            for (let i = 0; i < CONFIG.downloadSources.length; i++) {
                const source = CONFIG.downloadSources[i];
                
                try {
                    console.log(`Attempting download from: ${source.name} - ${source.url}`);
                    
                    let arrayBuffer;
                    
                    if (source.method === "api") {
                        // GitHub API method
                        const response = await fetch(source.url, {
                            headers: {
                                'Authorization': `token ${CONFIG.githubToken}`,
                                'Accept': 'application/vnd.github.v3+json'
                            },
                            cache: 'no-cache'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            // Store SHA for collaboration
                            collaborationState.currentFileSHA = data.sha;
                            console.log('📥 File SHA updated from API:', collaborationState.currentFileSHA);
                            
                            // GitHub API returns base64 encoded content
                            const base64Content = data.content.replace(/\n/g, '');
                            const binaryString = atob(base64Content);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let j = 0; j < binaryString.length; j++) {
                                bytes[j] = binaryString.charCodeAt(j);
                            }
                            arrayBuffer = bytes.buffer;
                        } else {
                            throw new Error(`API Error: ${response.status} ${response.statusText}`);
                        }
                    } else {
                        // Direct fetch method (for GitHub Pages and proxy)
                        const timestamp = new Date().getTime();
                        const urlWithTimestamp = `${source.url}?t=${timestamp}`;
                        
                        const response = await fetch(urlWithTimestamp, {
                            cache: 'no-cache',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            }
                        });
                        
                        if (response.ok) {
                            arrayBuffer = await response.arrayBuffer();
                        } else {
                            throw new Error(`${source.name}: ${response.status} ${response.statusText}`);
                        }
                    }
                    
                    // Successfully got the file, now process it using ExcelJS
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);
                    
                    // Clear existing data
                    workbookData = {};
                    
                    workbook.worksheets.forEach(worksheet => {
                        const sheetName = worksheet.name;
                        const data = [];
                        
                        // Convert worksheet to array of arrays
                        worksheet.eachRow((row, rowNumber) => {
                            const rowData = [];
                            row.eachCell((cell, colNumber) => {
                                let cellValue = '';
                                if (cell.value !== null && cell.value !== undefined) {
                                    if (cell.value instanceof Date) {
                                        // Format dates as strings to match original behavior
                                        cellValue = cell.value.toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, '');
                                    } else if (typeof cell.value === 'object' && cell.value.text) {
                                        // Handle rich text
                                        cellValue = cell.value.text;
                                    } else {
                                        cellValue = String(cell.value);
                                    }
                                }
                                rowData[colNumber - 1] = cellValue; // ExcelJS uses 1-based indexing
                            });
                            data[rowNumber - 1] = rowData; // ExcelJS uses 1-based indexing
                        });
                        
                        workbookData[sheetName] = data;
                    });
                    

                    
                    loadWorkbookData();
                    isModified = false;
                    document.title = "Excel Collaborator - Active Outages";
                    
                    // Recalculate and format all duration cells with Excel precision
                    setTimeout(() => formatAllDurationCells(), 100);
                    setLoading(false);
                    
                    if (showSuccessToast) {
                        showToast('Success', 
                            `File downloaded from ${source.name}`, 
                            'success', 3000);
                    }
                    
                    console.log(`✅ Successfully downloaded from: ${source.name}`);
                    return true;
                    
                } catch (error) {
                    console.warn(`❌ Failed to download from ${source.name}:`, error.message);
                    lastError = error;
                    
                    // If this isn't the last source, continue to next
                    if (i < CONFIG.downloadSources.length - 1) {
                        continue;
                    }
                }
            }
            
            // All sources failed
            setLoading(false);
            if (showSuccessToast) {
                showToast('Download Error', 
                    `Failed to download file from all sources. Last error: ${lastError?.message || 'Unknown error'}. Please check your internet connection and try again.`, 
                    'error', 8000);
            }
            throw lastError || new Error('All download sources failed');
        }

        async function saveToGitHub() {
            if (Object.keys(workbookData).length === 0) {
                showToast('Warning', 'No data to save!', 'warning', 3000);
                return;
            }
            
            setLoading(true);
            
            try {
                // Get current data from tables (optimized)
                updateWorkbookFromTables();
                
                // Create Excel file using ExcelJS
                const workbook = new ExcelJS.Workbook();
                
                Object.entries(workbookData).forEach(([sheetName, data]) => {
                    const worksheet = workbook.addWorksheet(sheetName);
                    if (data.length > 0) {
                        worksheet.addRows(data);
                    }
                });
                
                const excelBuffer = await workbook.xlsx.writeBuffer();
                const base64Content = btoa(String.fromCharCode(...new Uint8Array(excelBuffer)));
                
                // Get current file SHA
                const getUrl = `https://api.github.com/repos/${CONFIG.repoOwner}/${CONFIG.repoName}/contents/${CONFIG.filePath}`;
                const getResponse = await fetch(getUrl, {
                    headers: {
                        'Authorization': `token ${CONFIG.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                let sha = null;
                if (getResponse.ok) {
                    const fileData = await getResponse.json();
                    sha = fileData.sha;
                }
                
                // Upload file
                const uploadData = {
                    message: `Update Active_Outages.xlsx - ${new Date().toLocaleString()}`,
                    content: base64Content,
                    branch: 'main'
                };
                
                if (sha) {
                    uploadData.sha = sha;
                }
                
                const uploadResponse = await fetch(getUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${CONFIG.githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(uploadData)
                });
                
                if (uploadResponse.ok) {
                    isModified = false;
                    document.title = "Excel Collaborator - Active Outages";
                    
                    // Update collaboration SHA after successful save
                    const uploadResult = await uploadResponse.json();
                    if (uploadResult.content && uploadResult.content.sha) {
                        collaborationState.currentFileSHA = uploadResult.content.sha;
                        console.log('📤 File SHA updated after save:', collaborationState.currentFileSHA);
                    }
                    
                    setLoading(false);
                    
                    // Show save success and start auto-refresh countdown
                    showToast('Success', 'File saved successfully', 'success', 2000);
                    
                    // Start auto-refresh process after delay
                    startAutoRefreshAfterSave();
                    
                } else {
                    throw new Error(`HTTP ${uploadResponse.status}: ${uploadResponse.statusText}`);
                }
                
            } catch (error) {
                setLoading(false);
                showToast('Save Error', `Failed to save file: ${error.message}`, 'error', 6000);
            }
        }

        // Auto-refresh functionality after save
        async function startAutoRefreshAfterSave() {
            let attempt = 1;
            
            // Initial delay before first refresh attempt
            const initialDelay = CONFIG.autoRefreshDelay;
            
            // Show countdown toast
            const countdownToast = showToast('Auto-Refresh', 
                `Waiting ${Math.ceil(initialDelay/1000)} seconds before refreshing to get saved data...`, 
                'info', initialDelay + 1000);
            
            // Update countdown every second
            let remainingTime = Math.ceil(initialDelay / 1000);
            const countdownInterval = setInterval(() => {
                remainingTime--;
                if (remainingTime > 0) {
                    const messageElement = countdownToast.querySelector('.toast-message');
                    if (messageElement) {
                        messageElement.textContent = `Waiting ${remainingTime} seconds before refreshing to get saved data...`;
                    }
                } else {
                    clearInterval(countdownInterval);
                }
            }, 1000);
            
            // Wait for initial delay
            await new Promise(resolve => setTimeout(resolve, initialDelay));
            
            // Clear countdown interval
            clearInterval(countdownInterval);
            
            // Start refresh attempts
            while (attempt <= CONFIG.autoRefreshMaxAttempts) {
                try {
                    setLoading(true);
                    
                    showToast('Auto-Refresh', 
                        `Refreshing data (attempt ${attempt}/${CONFIG.autoRefreshMaxAttempts})...`, 
                        'info', 2000);
                    
                    // Attempt to refresh data
                    await downloadFromGitHub(false);
                    
                    setLoading(false);
                    
                    // Success - show confirmation
                    showToast('Auto-Refresh Complete', 
                        `Data refreshed successfully! Your saved changes are now loaded.`, 
                        'success', 4000);
                    
                    // Format duration cells after refresh
                    setTimeout(() => formatAllDurationCells(), 100);
                    
                    return; // Exit successfully
                    
                } catch (error) {
                    console.warn(`Auto-refresh attempt ${attempt} failed:`, error.message);
                    setLoading(false);
                    
                    if (attempt < CONFIG.autoRefreshMaxAttempts) {
                        // Not the last attempt - wait and retry
                        showToast('Auto-Refresh Retry', 
                            `Attempt ${attempt} failed, retrying in ${CONFIG.autoRefreshRetryDelay/1000} seconds...`, 
                            'warning', CONFIG.autoRefreshRetryDelay);
                        
                        await new Promise(resolve => setTimeout(resolve, CONFIG.autoRefreshRetryDelay));
                        attempt++;
                    } else {
                        // Last attempt failed
                        showToast('Auto-Refresh Failed', 
                            `Auto-refresh failed after ${CONFIG.autoRefreshMaxAttempts} attempts. Please manually refresh to see your saved changes.`, 
                            'error', 6000);
                        return;
                    }
                }
            }
        }

        async function refreshLookupData(showSuccessToast = true) {
            setLoading(true);
            
            let lastError = null;
            
            // Try each lookup source in order
            for (let i = 0; i < CONFIG.lookupSources.length; i++) {
                const source = CONFIG.lookupSources[i];
                
                try {
                    console.log(`Attempting lookup download from: ${source.name} - ${source.url}`);
                    
                    let arrayBuffer;
                    
                    if (source.method === "api") {
                        // GitHub API method
                        const response = await fetch(source.url, {
                            headers: {
                                'Authorization': `token ${CONFIG.githubToken}`,
                                'Accept': 'application/vnd.github.v3+json'
                            },
                            cache: 'no-cache'
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            // GitHub API returns base64 encoded content
                            const base64Content = data.content.replace(/\n/g, '');
                            const binaryString = atob(base64Content);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let j = 0; j < binaryString.length; j++) {
                                bytes[j] = binaryString.charCodeAt(j);
                            }
                            arrayBuffer = bytes.buffer;
                        } else {
                            throw new Error(`API Error: ${response.status} ${response.statusText}`);
                        }
                    } else {
                        // Direct fetch method (for GitHub Pages and proxy)
                        const timestamp = new Date().getTime();
                        const urlWithTimestamp = `${source.url}?t=${timestamp}`;
                        
                        const response = await fetch(urlWithTimestamp, {
                            cache: 'no-cache',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate',
                                'Pragma': 'no-cache',
                                'Expires': '0'
                            }
                        });
                        
                        if (response.ok) {
                            arrayBuffer = await response.arrayBuffer();
                        } else {
                            throw new Error(`${source.name}: ${response.status} ${response.statusText}`);
                        }
                    }
                    
                    // Successfully got the lookup file, now process it using ExcelJS
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(arrayBuffer);
                    
                    const dataWorksheet = workbook.getWorksheet('Data');
                    if (dataWorksheet) {
                        const data = [];
                        
                        // Convert worksheet to array of arrays
                        dataWorksheet.eachRow((row, rowNumber) => {
                            const rowData = [];
                            row.eachCell((cell, colNumber) => {
                                let cellValue = '';
                                if (cell.value !== null && cell.value !== undefined) {
                                    if (cell.value instanceof Date) {
                                        cellValue = cell.value.toISOString().replace('T', ' ').replace(/\.\d{3}Z$/, '');
                                    } else if (typeof cell.value === 'object' && cell.value.text) {
                                        cellValue = cell.value.text;
                                    } else {
                                        cellValue = String(cell.value);
                                    }
                                }
                                rowData[colNumber - 1] = cellValue;
                            });
                            data[rowNumber - 1] = rowData;
                        });
                        
                        if (data.length > 0) {
                            const headers = data[0];
                            
                            // Find column indices
                            const siteIdCol = headers.findIndex(h => h && h.includes('Site ID Code'));
                            const regionCol = headers.findIndex(h => h && h.trim() === 'Region');
                            const powerTypeCol = headers.findIndex(h => h && h.includes('Power Type'));
                            const bbStatusCol = headers.findIndex(h => h && h.includes('BB Status'));
                            const siteOwnerCol = headers.findIndex(h => h && h.includes('Site Owner'));
                            
                            console.log('Lookup column mapping:', { siteIdCol, regionCol, powerTypeCol, bbStatusCol, siteOwnerCol });
                            
                            // Build lookup dictionary with case-insensitive keys (optimized)
                            lookupData = {};
                            for (let k = 1; k < data.length; k++) {
                                const row = data[k];
                                if (siteIdCol >= 0 && row[siteIdCol]) {
                                    const siteId = String(row[siteIdCol]).trim().toUpperCase();
                                    if (siteId) {
                                        lookupData[siteId] = {
                                            Region: regionCol >= 0 ? row[regionCol] || '' : '',
                                            'Power Type': powerTypeCol >= 0 ? row[powerTypeCol] || '' : '',
                                            'BB Status': bbStatusCol >= 0 ? row[bbStatusCol] || '' : '',
                                            'Site Owner': siteOwnerCol >= 0 ? row[siteOwnerCol] || '' : ''
                                        };
                                    }
                                }
                            }
                            
                            setLoading(false);
                            
                            if (showSuccessToast) {
                                showToast('Success', 
                                    `Lookup data refreshed from ${source.name}`, 
                                    'success', 3000);
                            }
                            
                            console.log(`✅ Successfully downloaded lookup data from: ${source.name}`);
                            return true;
                        } else {
                            throw new Error('Data sheet found but no data rows!');
                        }
                    } else {
                        throw new Error(`'Data' sheet not found. Available sheets: ${workbook.worksheets.map(ws => ws.name).join(', ')}`);
                    }
                    
                } catch (error) {
                    console.warn(`❌ Failed to download lookup data from ${source.name}:`, error.message);
                    lastError = error;
                    
                    // If this isn't the last source, continue to next
                    if (i < CONFIG.lookupSources.length - 1) {
                        continue;
                    }
                }
            }
            
            // All lookup sources failed
            setLoading(false);
            if (showSuccessToast) {
                showToast('Lookup Error', 
                    `Failed to download lookup data from all sources. Last error: ${lastError?.message || 'Unknown error'}. Please check your internet connection and try again.`, 
                    'error', 8000);
            }
            throw lastError || new Error('All lookup sources failed');
        }

        async function autoFillColumns() {
            if (Object.keys(lookupData).length === 0) {
                const shouldRefresh = await showModal('No Lookup Data', 
                    'Lookup data not loaded. Would you like to download it first?', true);
                if (shouldRefresh) {
                    await refreshLookupData(true);
                }
                return;
            }
            
            if (!currentSheet) {
                await showModal('Warning', 'No active sheet selected!');
                return;
            }
            
            setLoading(true);
            
            try {
                const table = document.querySelector(`#tab-${currentSheet} table`);
                if (!table) {
                    throw new Error('Table not found');
                }
                
                const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent);
                
                // Find column indices
                const hubSiteCol = headers.findIndex(h => h.toLowerCase().includes('hub site'));
                const pcmCreatedCol = headers.findIndex(h => h.toLowerCase().includes('pcm created'));
                const elapsedDurationCol = headers.findIndex(h => h.toLowerCase().includes('elapsed duration'));
                const regionCol = headers.findIndex(h => h.toLowerCase() === 'region');
                const powerSourceCol = headers.findIndex(h => h.toLowerCase().includes('power source'));
                const bbStatusCol = headers.findIndex(h => h.toLowerCase().includes('battery backup status'));
                const siteOwnerCol = headers.findIndex(h => h.toLowerCase().includes('site owner'));
                
                console.log('Column mapping:', { hubSiteCol, pcmCreatedCol, elapsedDurationCol, regionCol, powerSourceCol, bbStatusCol, siteOwnerCol });
                
                let filledCount = 0;
                const rows = table.querySelectorAll('tbody tr');
                
                rows.forEach((row, rowIndex) => {
                    const cells = row.querySelectorAll('td');
                    
                    // Get Hub Site ID for lookup
                    let hubSiteId = null;
                    if (hubSiteCol >= 0 && cells[hubSiteCol]) {
                        const textarea = cells[hubSiteCol].querySelector('textarea');
                        hubSiteId = textarea ? textarea.value.trim() : cells[hubSiteCol].textContent.trim();
                    }
                    
                    // Calculate Elapsed Duration - only if PCM Created At has a value
                    if (elapsedDurationCol >= 0 && pcmCreatedCol >= 0 && cells[pcmCreatedCol] && cells[elapsedDurationCol]) {
                        const pcmTextarea = cells[pcmCreatedCol].querySelector('textarea');
                        const pcmText = pcmTextarea ? pcmTextarea.value.trim() : cells[pcmCreatedCol].textContent.trim();
                        
                        if (pcmText) {
                            try {
                                const pcmDate = new Date(pcmText);
                                if (!isNaN(pcmDate.getTime())) {
                                    const now = new Date();
                                    
                                    // Calculate time difference exactly like Excel
                                    const MS_PER_SECOND = 1000;
                                    const MS_PER_MINUTE = 60 * MS_PER_SECOND;
                                    const MS_PER_HOUR = 60 * MS_PER_MINUTE;
                                    
                                    // Get total milliseconds difference
                                    const msDiff = now - pcmDate;
                                    
                                    // Calculate hours, minutes, seconds precisely 
                                    const totalHours = Math.floor(msDiff / MS_PER_HOUR);
                                    const remainingMs = msDiff % MS_PER_HOUR;
                                    const totalMinutes = Math.floor(remainingMs / MS_PER_MINUTE);
                                    const totalSeconds = Math.floor((remainingMs % MS_PER_MINUTE) / MS_PER_SECOND);
                                    
                                    // Store exact values for formatting
                                    const durationHours = totalHours + (totalMinutes / 60) + (totalSeconds / 3600);
                                    
                                    const durationTextarea = cells[elapsedDurationCol].querySelector('textarea');
                                    if (durationTextarea) {
                                        // Store raw hours for precise calculations
                                        durationTextarea.dataset.rawHours = durationHours;
                                        durationTextarea.value = durationHours.toString();
                                        formatDuration(durationTextarea);
                                        filledCount++;
                                    }
                                }
                            } catch (e) {
                                console.log(`Error calculating duration for row ${rowIndex}:`, e);
                            }
                        } else {
                            // Clear duration if PCM Created At is empty
                            const durationTextarea = cells[elapsedDurationCol].querySelector('textarea');
                            if (durationTextarea && durationTextarea.value) {
                                durationTextarea.value = '';
                                durationTextarea.classList.remove('elapsed-duration-live');
                                filledCount++;
                            }
                        }
                    }
                    
                    // Lookup values if Hub Site ID exists
                    if (hubSiteId && lookupData[hubSiteId]) {
                        const lookupRecord = lookupData[hubSiteId];
                        
                        // Fill Region
                        if (regionCol >= 0 && cells[regionCol] && lookupRecord.Region) {
                            const regionTextarea = cells[regionCol].querySelector('textarea');
                            if (regionTextarea) {
                                regionTextarea.value = lookupRecord.Region;
                                filledCount++;
                            }
                        }
                        
                        // Fill Power Source
                        if (powerSourceCol >= 0 && cells[powerSourceCol] && lookupRecord['Power Type']) {
                            const powerTextarea = cells[powerSourceCol].querySelector('textarea');
                            if (powerTextarea) {
                                powerTextarea.value = lookupRecord['Power Type'];
                                filledCount++;
                            }
                        }
                        
                        // Fill Battery Backup Status
                        if (bbStatusCol >= 0 && cells[bbStatusCol] && lookupRecord['BB Status']) {
                            const bbTextarea = cells[bbStatusCol].querySelector('textarea');
                            if (bbTextarea) {
                                bbTextarea.value = lookupRecord['BB Status'];
                                filledCount++;
                            }
                        }
                        
                        // Fill Site Owner
                        if (siteOwnerCol >= 0 && cells[siteOwnerCol] && lookupRecord['Site Owner']) {
                            const ownerTextarea = cells[siteOwnerCol].querySelector('textarea');
                            if (ownerTextarea) {
                                ownerTextarea.value = lookupRecord['Site Owner'];
                                filledCount++;
                            }
                        }
                    }
                });
                
                markAsModified();
                setLoading(false);
                
                await showModal('Auto-Fill Complete', 
                    `Auto-fill completed for ${currentSheet}. Filled ${filledCount} cells.`);
                
            } catch (error) {
                setLoading(false);
                await showModal('Error', `Error during auto-fill:\n${error.message}`);
            }
        }

        function addRow() {
            if (!currentSheet) {
                showToast('Warning', 'No active sheet selected!', 'warning', 3000);
                return;
            }
            
            const table = document.querySelector(`#tab-${currentSheet} table tbody`);
            if (table) {
                const headerCount = document.querySelectorAll(`#tab-${currentSheet} table th`).length;
                const row = table.insertRow();
                
                // Get headers to identify special columns
                const headers = Array.from(document.querySelectorAll(`#tab-${currentSheet} table th`)).map(th => th.textContent);
                const emFieldFeedbackColIndex = headers.findIndex(h => h && h.toLowerCase().includes('em field feedback'));
                
                for (let i = 0; i < headerCount; i++) {
                    const cell = row.insertCell();
                    
                    // Add special class for EM Field Feedback column
                    if (i === emFieldFeedbackColIndex) {
                        cell.classList.add('em-field-feedback');
                    }
                    
                    // Create appropriate input element (textarea or select) based on column type
                    const inputElement = createInputElement(headers[i], '', i, currentSheet, headers);
                    
                    cell.appendChild(inputElement);
                }
                
                debouncedMarkModified();
                
                // Add row resize handle for the new row
                const rowIndex = table.rows.length - 1;
                const newRow = table.rows[rowIndex];
                
                const rowResizeHandle = document.createElement('div');
                rowResizeHandle.className = 'row-resize-handle';
                rowResizeHandle.title = 'Drag to resize row';
                newRow.appendChild(rowResizeHandle);
                
                // Add row resize functionality using global functions
                rowResizeHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    resizeState.startY = e.clientY;
                    resizeState.currentRow = newRow;
                    resizeState.startHeight = newRow.offsetHeight;
                    resizeState.currentSheet = currentSheet;
                    resizeState.rowIndex = rowIndex;
                    
                    document.body.style.cursor = 'row-resize';
                    newRow.classList.add('resizing');
                    rowResizeHandle.classList.add('active');
                    
                    document.addEventListener('mousemove', handleRowResize);
                    document.addEventListener('mouseup', stopRowResize);
                });
                
                showToast('Success', 'New row added', 'success', 2000);
            }
        }

        function deleteRow() {
            if (!currentSheet) {
                showToast('Warning', 'No active sheet selected!', 'warning', 3000);
                return;
            }
            
            const table = document.querySelector(`#tab-${currentSheet} table tbody`);
            if (table && table.rows.length > 0) {
                table.deleteRow(-1); // Delete last row
                debouncedMarkModified();
                showToast('Success', 'Last row deleted', 'success', 2000);
            } else {
                showToast('Warning', 'No rows to delete!', 'warning', 3000);
            }
        }

        // Optimized real-time lookup functionality
        function performRealTimeLookup(hubSiteInput, sheetName) {
            // Convert to uppercase automatically
            const originalValue = hubSiteInput.value;
            const hubSiteId = originalValue.trim().toUpperCase();
            
            // Update the input field to show uppercase
            if (originalValue !== hubSiteId) {
                hubSiteInput.value = hubSiteId;
            }
            
            // Clear if empty
            if (!hubSiteId) {
                clearRelatedFields(hubSiteInput, sheetName);
                return;
            }
            
            // Case-insensitive lookup
            let lookupRecord = null;
            const lookupKeys = Object.keys(lookupData);
            
            // First try exact match
            if (lookupData[hubSiteId]) {
                lookupRecord = lookupData[hubSiteId];
            } else {
                // Try case-insensitive search
                const foundKey = lookupKeys.find(key => key.toUpperCase() === hubSiteId);
                if (foundKey) {
                    lookupRecord = lookupData[foundKey];
                }
            }
            
            if (!lookupRecord) {
                // Show hint if partial match exists
                const partialMatches = lookupKeys.filter(key => 
                    key.toUpperCase().includes(hubSiteId) || hubSiteId.includes(key.toUpperCase())
                ).slice(0, 3);
                
                if (partialMatches.length > 0 && hubSiteId.length > 2) {
                    // Similar sites found but don't show status message
                } else if (hubSiteId.length > 3) {
                    // Hub site not found but don't show status message
                }
                clearRelatedFields(hubSiteInput, sheetName);
                return;
            }
            
            try {
                // Find the row containing this input
                const row = hubSiteInput.closest('tr');
                if (!row) return;
                
                // Get headers to find column indices
                const headers = Array.from(document.querySelectorAll(`#tab-${sheetName} table th`)).map(th => th.textContent);
                
                // Find column indices
                const regionCol = headers.findIndex(h => h.toLowerCase() === 'region');
                const powerSourceCol = headers.findIndex(h => h.toLowerCase().includes('power source'));
                const bbStatusCol = headers.findIndex(h => h.toLowerCase().includes('battery backup status'));
                const siteOwnerCol = headers.findIndex(h => h.toLowerCase().includes('site owner'));
                
                const cells = row.querySelectorAll('td');
                let filledCount = 0;
                
                // Fill Region
                if (regionCol >= 0 && cells[regionCol] && lookupRecord.Region) {
                    const regionTextarea = cells[regionCol].querySelector('textarea');
                    if (regionTextarea && regionTextarea.value !== lookupRecord.Region) {
                        regionTextarea.value = lookupRecord.Region;
                        regionTextarea.classList.add('auto-filled');
                        setTimeout(() => regionTextarea.classList.remove('auto-filled'), 3000);
                        filledCount++;
                    }
                }
                
                // Fill Power Source
                if (powerSourceCol >= 0 && cells[powerSourceCol] && lookupRecord['Power Type']) {
                    const powerTextarea = cells[powerSourceCol].querySelector('textarea');
                    if (powerTextarea && powerTextarea.value !== lookupRecord['Power Type']) {
                        powerTextarea.value = lookupRecord['Power Type'];
                        powerTextarea.classList.add('auto-filled');
                        setTimeout(() => powerTextarea.classList.remove('auto-filled'), 3000);
                        filledCount++;
                    }
                }
                
                // Fill Battery Backup Status
                if (bbStatusCol >= 0 && cells[bbStatusCol] && lookupRecord['BB Status']) {
                    const bbTextarea = cells[bbStatusCol].querySelector('textarea');
                    if (bbTextarea && bbTextarea.value !== lookupRecord['BB Status']) {
                        bbTextarea.value = lookupRecord['BB Status'];
                        bbTextarea.classList.add('auto-filled');
                        setTimeout(() => bbTextarea.classList.remove('auto-filled'), 3000);
                        filledCount++;
                    }
                }
                
                // Fill Site Owner
                if (siteOwnerCol >= 0 && cells[siteOwnerCol] && lookupRecord['Site Owner']) {
                    const ownerTextarea = cells[siteOwnerCol].querySelector('textarea');
                    if (ownerTextarea && ownerTextarea.value !== lookupRecord['Site Owner']) {
                        ownerTextarea.value = lookupRecord['Site Owner'];
                        ownerTextarea.classList.add('auto-filled');
                        setTimeout(() => ownerTextarea.classList.remove('auto-filled'), 3000);
                        filledCount++;
                    }
                }
                
                if (filledCount > 0) {
                    debouncedMarkModified();
                    // Auto-filled fields but don't show status message
                } else {
                    // Hub site verified but don't show status message
                }
                
            } catch (error) {
                console.error('Error in real-time lookup:', error);
                // Error during lookup but don't show status message
            }
        }

        function clearRelatedFields(hubSiteInput, sheetName) {
            try {
                const row = hubSiteInput.closest('tr');
                if (!row) return;
                
                const headers = Array.from(document.querySelectorAll(`#tab-${sheetName} table th`)).map(th => th.textContent);
                const regionCol = headers.findIndex(h => h.toLowerCase() === 'region');
                const powerSourceCol = headers.findIndex(h => h.toLowerCase().includes('power source'));
                const bbStatusCol = headers.findIndex(h => h.toLowerCase().includes('battery backup status'));
                const siteOwnerCol = headers.findIndex(h => h.toLowerCase().includes('site owner'));
                
                const cells = row.querySelectorAll('td');
                
                // Clear related fields when Hub Site is empty or invalid
                [regionCol, powerSourceCol, bbStatusCol, siteOwnerCol].forEach(colIndex => {
                    if (colIndex >= 0 && cells[colIndex]) {
                        const textarea = cells[colIndex].querySelector('textarea');
                        if (textarea && textarea.value) {
                            textarea.value = '';
                            textarea.classList.remove('auto-filled');
                        }
                    }
                });
            } catch (error) {
                console.error('Error clearing related fields:', error);
            }
        }

        // Helper function to create appropriate input element based on column type
        function createInputElement(columnName, cellValue, colIndex, sheetName, headers) {
            const colName = columnName?.toLowerCase() || '';
            
            // Check if this is a Fault Level column
            if (colName.includes('fault level')) {
                // Create container for input and dropdown
                const container = document.createElement('div');
                container.className = 'fault-level-container';
                
                // Create input for Fault Level
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'editable fault-level-input';
                input.value = cellValue || '';
                input.setAttribute('autocomplete', 'off');
                
                // Create custom dropdown
                const dropdown = document.createElement('div');
                dropdown.className = 'fault-level-dropdown';
                
                const options = ['Emergency', 'Critical', 'Major', 'Minor'];
                options.forEach(optionValue => {
                    const option = document.createElement('div');
                    option.className = `fault-level-option ${optionValue.toLowerCase()}`;
                    option.textContent = optionValue;
                    option.addEventListener('click', () => {
                        input.value = optionValue;
                        dropdown.classList.remove('show');
                        input.classList.add('editing');
                        setTimeout(() => input.classList.remove('editing'), 500);
                        debouncedMarkModified();
                        input.blur(); // Remove focus after selection
                    });
                    dropdown.appendChild(option);
                });
                
                // Add event listeners for input
                input.addEventListener('input', (e) => {
                    e.target.classList.add('editing');
                    setTimeout(() => e.target.classList.remove('editing'), 500);
                    debouncedMarkModified();
                });
                
                input.addEventListener('change', (e) => {
                    e.target.classList.add('editing');
                    setTimeout(() => e.target.classList.remove('editing'), 500);
                    debouncedMarkModified();
                });
                
                // Function to position dropdown relative to input
                function positionDropdown() {
                    const rect = input.getBoundingClientRect();
                    dropdown.style.top = `${rect.bottom + 2}px`;
                    dropdown.style.left = `${rect.left}px`;
                    dropdown.style.width = `${Math.max(rect.width, 150)}px`;
                }
                
                // Show dropdown on focus/click
                input.addEventListener('focus', () => {
                    positionDropdown();
                    dropdown.classList.add('show');
                });
                
                input.addEventListener('click', () => {
                    positionDropdown();
                    dropdown.classList.add('show');
                });
                
                // Hide dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!container.contains(e.target) && !dropdown.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
                
                // Hide dropdown on blur (with slight delay for option clicks)
                input.addEventListener('blur', () => {
                    setTimeout(() => {
                        dropdown.classList.remove('show');
                    }, 150);
                });
                
                // Reposition dropdown on scroll or resize
                function hideDropdownOnMove() {
                    dropdown.classList.remove('show');
                }
                
                window.addEventListener('scroll', hideDropdownOnMove, true);
                window.addEventListener('resize', hideDropdownOnMove);
                
                // Cleanup function to remove dropdown when element is removed
                container.addEventListener('remove', () => {
                    if (dropdown.parentNode) {
                        dropdown.parentNode.removeChild(dropdown);
                    }
                });
                
                container.appendChild(input);
                
                // Append dropdown to body for fixed positioning
                document.body.appendChild(dropdown);
                
                return container;
            } else {
                // Create regular textarea for all other columns
                            const textarea = document.createElement('textarea');
                            textarea.className = 'editable';
                            
                // Find Hub Site column index for real-time lookup
                const hubSiteColIndex = headers.findIndex(h => h && h.toLowerCase().includes('hub site'));
                
                // Set value with special handling for Hub Site
                            if (colIndex === hubSiteColIndex && cellValue) {
                                textarea.value = String(cellValue).trim().toUpperCase();
                            } else {
                                textarea.value = cellValue || '';
                            }
                            
                // Add input event listener
                            textarea.addEventListener('input', (e) => {
                                e.target.classList.add('editing');
                                setTimeout(() => e.target.classList.remove('editing'), 500);
                                debouncedMarkModified();
                            });
                            
                            // Add real-time lookup for Hub Site column
                            if (colIndex === hubSiteColIndex) {
                                textarea.addEventListener('input', (e) => {
                                    e.target.classList.add('editing');
                                    setTimeout(() => e.target.classList.remove('editing'), 500);
                                    debouncedLookup(e.target, sheetName);
                                });
                                textarea.addEventListener('paste', (e) => {
                                    setTimeout(() => {
                                        debouncedLookup(e.target, sheetName);
                                    }, 10);
                                });
                                textarea.classList.add('hub-site-field');
                            }
                            
                            // Format date/time columns in yyyy-mm-dd hh:mm:ss
                            if (colName.includes('creat fault first time') || 
                                colName.includes('pcm created') || 
                                colName.includes('created at') ||
                                colName.includes('fault first time') ||
                                colName.includes('first time occured')) {
                                
                                // Add multiple event listeners for comprehensive date formatting
                                textarea.addEventListener('blur', (e) => formatDateTime(e.target));
                                textarea.addEventListener('change', (e) => formatDateTime(e.target));
                                textarea.addEventListener('paste', (e) => setTimeout(() => formatDateTime(e.target), 10));
                                textarea.addEventListener('focus', (e) => showDateFormatHelp(e.target));
                                textarea.addEventListener('input', (e) => {
                                    // Immediate clearing of duration when PCM field is emptied
                                    if (e.target.value.trim() === '') {
                                        formatDateTime(e.target); // Handle clearing immediately
                                    }
                                    // Debounced formatting to avoid excessive calls while typing
                                    clearTimeout(e.target.formatTimeout);
                                    e.target.formatTimeout = setTimeout(() => formatDateTime(e.target), 1000);
                                });
                                
                                textarea.classList.add('date-time-field');
                            }
                            
                            // Format elapsed duration column
                            if (colName.includes('elapsed duration')) {
                                textarea.addEventListener('blur', (e) => formatDuration(e.target));
                                textarea.addEventListener('paste', (e) => setTimeout(() => formatDuration(e.target), 10));
                                textarea.readOnly = true;
                                textarea.classList.add('elapsed-duration-live');
                }
                
                return textarea;
            }
        }

        // Clean up existing fault level dropdowns
        function cleanupFaultLevelDropdowns() {
            const existingDropdowns = document.querySelectorAll('.fault-level-dropdown');
            existingDropdowns.forEach(dropdown => {
                if (dropdown.parentNode) {
                    dropdown.parentNode.removeChild(dropdown);
                }
            });
        }

        // Optimized workbook data loading
        function loadWorkbookData() {
            // Clear existing tabs and cleanup dropdowns
            elements.tabsHeader.innerHTML = '';
            elements.tabsContent.innerHTML = '';
            cleanupFaultLevelDropdowns();
            
            let isFirst = true;
            
            Object.entries(workbookData).forEach(([sheetName, data]) => {
                // Create tab button
                const tab = document.createElement('button');
                tab.className = 'tab' + (isFirst ? ' active' : '');
                tab.textContent = sheetName;
                tab.addEventListener('click', () => switchTab(sheetName));
                elements.tabsHeader.appendChild(tab);
                
                // Create tab content
                const tabContent = document.createElement('div');
                tabContent.className = 'tab-content' + (isFirst ? ' active' : '');
                tabContent.id = `tab-${sheetName}`;
                
                if (data.length > 0) {
                    const tableContainer = document.createElement('div');
                    tableContainer.className = 'table-container';
                    
                    const table = document.createElement('table');
                    
                    // Create header
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    
                    const headers = data[0];
                    const emFieldFeedbackHeaderIndex = headers.findIndex(h => h && h.toLowerCase().includes('em field feedback'));
                    
                    headers.forEach((header, index) => {
                        const th = document.createElement('th');
                        th.textContent = header || '';
                        
                        // Add special class for EM Field Feedback column header
                        if (index === emFieldFeedbackHeaderIndex) {
                            th.classList.add('em-field-feedback');
                        }
                        
                        headerRow.appendChild(th);
                    });
                    
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Find Hub Site column index for real-time lookup
                    const hubSiteColIndex = headers.findIndex(h => h && h.toLowerCase().includes('hub site'));
                    const emFieldFeedbackColIndex = headers.findIndex(h => h && h.toLowerCase().includes('em field feedback'));
                    
                    // Create body
                    const tbody = document.createElement('tbody');
                    
                    for (let i = 1; i < data.length; i++) {
                        const row = document.createElement('tr');
                        
                        data[i].forEach((cellValue, colIndex) => {
                            const td = document.createElement('td');
                            
                            // Add special class for EM Field Feedback column
                            if (colIndex === emFieldFeedbackColIndex) {
                                td.classList.add('em-field-feedback');
                            }
                            
                            // Create appropriate input element (textarea or select) based on column type
                            const inputElement = createInputElement(headers[colIndex], cellValue, colIndex, sheetName, headers);
                            
                            td.appendChild(inputElement);
                            row.appendChild(td);
                        });
                        
                        tbody.appendChild(row);
                    }
                    
                    table.appendChild(tbody);
                    tableContainer.appendChild(table);
                    tabContent.appendChild(tableContainer);
                    
                    // Setup table resizing functionality
                    setupTableResizing(tableContainer, sheetName);
                    
                    // Apply current styling and redistribute width
                    setTimeout(() => {
                        applyTableStyling();
                        redistributeTableWidth(table, sheetName);
                    }, 100);
                } else {
                    tabContent.innerHTML = '<p>No data available</p>';
                }
                
                elements.tabsContent.appendChild(tabContent);
                
                if (isFirst) {
                    currentSheet = sheetName;
                    isFirst = false;
                }
            });
        }

        function switchTab(sheetName) {
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.textContent === sheetName);
            });
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.toggle('active', content.id === `tab-${sheetName}`);
            });
            
            currentSheet = sheetName;
            
            // Apply current styling and redistribute width to the newly active sheet
            setTimeout(() => {
                applyTableStyling();
                const table = document.querySelector(`#tab-${sheetName} table`);
                if (table) {
                    redistributeTableWidth(table, sheetName);
                }
            }, 100);
        }

        function updateWorkbookFromTables() {
            Object.keys(workbookData).forEach(sheetName => {
                const table = document.querySelector(`#tab-${sheetName} table`);
                if (table) {
                    const data = [];
                    
                    // Get headers
                    const headers = Array.from(table.querySelectorAll('th')).map(th => th.textContent);
                    data.push(headers);
                    
                    // Get data rows
                    const rows = table.querySelectorAll('tbody tr');
                    rows.forEach(row => {
                        const rowData = [];
                        const cells = row.querySelectorAll('td');
                        cells.forEach(cell => {
                            // Check if cell contains a fault level container or regular input
                            const container = cell.querySelector('.fault-level-container');
                            if (container) {
                                const input = container.querySelector('.fault-level-input');
                                rowData.push(input ? input.value : '');
                            } else {
                                const input = cell.querySelector('.editable');
                                rowData.push(input ? input.value : '');
                            }
                        });
                        data.push(rowData);
                    });
                    
                    workbookData[sheetName] = data;
                }
            });
        }

        // Auto-sync every 30 seconds
        setInterval(async () => {
            if (!isModified && Object.keys(workbookData).length > 0) {
                console.log('Auto-syncing...');
                // Only download if no modifications to avoid conflicts
                // await downloadFromGitHub();
            }
        }, 30000);

        // Initialize app - Auto load all data immediately
        window.addEventListener('load', async () => {
            setLoading(true);
            
            // Load saved format settings first
            loadSavedFormat();
            
            // Load saved auto-refresh settings
            loadAutoRefreshSettings();
            
            // Load saved collaboration settings
            loadCollaborationSettings();
            
            try {
                // Step 1: Load API token from remote JSON first
                const tokenLoaded = await loadApiTokenFromRemote();
                
                if (!tokenLoaded) {
                    showToast('Error', 'Failed to load API token. Cannot proceed.', 'error', 8000);
                    setLoading(false);
                    return;
                }
                
                // Step 2: Auto-load both files simultaneously after token is loaded
                const [mainFileResult, lookupResult] = await Promise.allSettled([
                    downloadFromGitHub(false),
                    refreshLookupData(false)
                ]);
                
                if (mainFileResult.status === 'fulfilled' && lookupResult.status === 'fulfilled') {
                    showToast('Success', 
                        `Data loaded! ${Object.keys(workbookData).length} sheets ready`, 
                        'success', 3000);
                    setLoading(false);
                    
                    // Start live updates for elapsed duration
                    startLiveUpdates();
                    
                    // Start live collaboration if enabled
                    if (CONFIG.liveCollaboration.enabled) {
                        startLiveCollaboration();
                    }
                    
                } else {
                    // Handle partial failures
                    let errorMessages = [];
                    if (mainFileResult.status === 'rejected') {
                        errorMessages.push(`Main file: ${mainFileResult.reason}`);
                    }
                    if (lookupResult.status === 'rejected') {
                        errorMessages.push(`Lookup data: ${lookupResult.reason}`);
                    }
                    
                    showToast('Warning', 
                        `Some files failed to load: ${errorMessages.join(', ')}`, 
                        'warning', 6000);
                    setLoading(false);
                }
            } catch (error) {
                showToast('Error', `Failed to load data: ${error.message}`, 'error', 5000);
                setLoading(false);
            }
        });

        // Handle page unload
        window.addEventListener('beforeunload', (e) => {
            stopLiveUpdates(); // Clean up intervals
            stopLiveCollaboration(); // Clean up collaboration polling
            if (isModified) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
            }
        });
    </script>
</body>
</html>
