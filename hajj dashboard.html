<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Haj PCMs Overview</title>

  <!-- Excel parsing & Chart.js + DataLabels -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <!-- html2canvas & jsPDF for PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <!-- Flatpickr DateTime Picker -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <style>
    /* RESET & LAYOUT */
    * { box-sizing:border-box; margin:0; padding:0 }
    body { 
      font-family:Arial; padding:20px; color:#333; 
      background-image: url('https://tarek-mahran.github.io/shabakkat/HAJ_Dashboard_Background.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-attachment: fixed;
      background-position: center;
      min-height: 100vh;
    }
    h1 {
      font-size:24px; font-weight:bold; text-align:center;
      margin-bottom:12px; position:relative;
      color: #333; text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.8);
      background: rgba(255, 255, 255, 0.75);
      padding: 20px 30px; border-radius: 8px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      min-height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      max-width: 1320px;
      margin: 0 auto 12px auto;
    }
    .logo {
      height: 120px;
      width: 250px;
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    .logo-left {
      height: 65px;
      width: 250px;
      position: absolute;
      left: 40px;
      top: 52%;
      transform: translateY(-50%);
    }
    
    .toggle-btn {
      position: absolute;
      bottom: -15px;
      left: 50%;
      transform: translateX(-50%);
      width: 30px;
      height: 30px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #bbb;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
    }
    
    .toggle-btn:hover {
      background: rgba(255, 255, 255, 1);
      transform: translateX(-50%) scale(1.1);
    }
    
    .toggle-btn.rotated {
      transform: translateX(-50%) rotate(180deg);
    }
    
    .toggle-btn.rotated:hover {
      transform: translateX(-50%) rotate(180deg) scale(1.1);
    }
    
    .arrow-down {
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 8px solid #666;
    }
    h1::after {
      display: none;
    }
    #controls { 
      text-align:center; margin:20px auto; 
      background: rgba(255, 255, 255, 0.75);
      padding: 15px;
      border-radius: 8px;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      display: none;
      max-width: 1320px;
    }
    #controls button { margin-left:12px; padding:6px 12px; }
    #controls select { margin-left:12px; padding:6px 10px; border-radius:4px; border:1px solid #ccc; background:#fff; }
    #controls input[type="file"] { margin-right:12px; }
    #region-filter, #subproject-filter { min-width:150px; }
    #auto-mode-btn.active { background-color:#109618; color:white; }
    #refresh-interval:disabled { opacity:0.6; cursor:not-allowed; }
    
    
    .date-filter-container {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      border: none;
      border-radius: 12px;
      background: #ffffff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      margin: 0 12px;
    }

    .date-filter-container label {
      font-weight: 600;
      color: #333;
      font-size: 14px;
      margin-right: 4px;
    }

    .date-filter-container input[type="text"] {
      width: 140px;
      padding: 6px 8px;
      border: none;
      border-radius: 6px;
      background: #f1f3f5;
      text-align: center;
      font-family: monospace;
      font-size: 13px;
    }

    .date-filter-container input[type="text"]:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(16,150,24,0.3);
    }

    .date-filter-container span {
      margin: 0 4px;
      color: #666;
      font-size: 14px;
    }

    .date-filter-container button {
      padding: 6px 10px;
      background: #ff6b6b;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }

    .date-filter-container button:hover {
      background: #ff5252;
    }


    /* DASHBOARD GRID */
    .dashboard {
      display:grid;
      grid-template-columns:repeat(4,minmax(300px,1fr));
      gap:20px; max-width:1320px; margin:0 auto;
      justify-content:center;
    }

    /* CARD */
    .card {
      border:1px solid #777; border-radius:10px;
      padding:16px; display:flex; flex-direction:column;
      background:rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }
    .card h2 {
      font-size:16px; font-weight:bold; text-align:center;
      margin-bottom:8px; position:relative;
    }
    .card h2::after {
      content:""; position:absolute; bottom:0;
      left:16px; right:16px; height:1px; background:#777;
    }

    /* METRIC BOX & BADGE */
    .metric-box {
      border:1px solid #bbb; border-radius:6px;
      padding:12px; margin:12px 0; position:relative;
      min-height:110px; /* Added consistent minimum height */
      display:flex;
      flex-direction:column;
      justify-content:center;
      background:rgba(255, 255, 255, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .big-number { text-align:center; font-weight:300; font-size:40px; }
    .badge {
      position:absolute; bottom:8px; right:8px;
      border:1px solid #bbb; border-radius:4px;
      padding:2px 6px; font-size:12px; background:#fff;
    }

    /* REPETITION ICON STYLING */
    .repetition-icon {
      position:absolute; top:8px; left:8px; font-size:18px;
    }

    /* FAULT GRID */
    .fault-grid {
      display:grid; grid-template-columns:1fr 1fr;
      grid-template-rows:1fr 1fr; gap:12px; margin:16px 0;
    }
    .fault-box {
      border:1px solid #bbb; border-radius:6px;
      padding:12px 8px 8px; position:relative;
      background:rgba(255, 255, 255, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .fault-icon { position:absolute; top:8px; left:8px; font-size:18px; }
    .fault-value {
      text-align:center; font-size:28px; font-weight:300;
      margin-top:12px;
    }
    .fault-label { text-align:center; font-size:14px; margin-top:4px; }
    .emergency { color:red;    border-radius:12px 0 0 0; }
    .critical  { color:orange; border-radius:0 12px 0 0; }
    .major     { color:gold;   border-radius:0 0 0 12px; }
    .minor     { color:blue;   border-radius:0 0 12px 0; }

    /* SUB-BOX FOR CHARTS */
    .sub-box {
      border:1px solid #bbb; border-radius:6px;
      padding:8px; margin:12px 0; position:relative;
      background:rgba(255, 255, 255, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* STATUS BOX */
    .sub-metrics { display:flex; justify-content:space-between; }
    .status-box {
      width:48%; border:1px solid #bbb; border-radius:6px;
      padding:16px 12px 24px; position:relative;
      background:rgba(255, 255, 255, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .status-icon {
      position:absolute; top:-12px; left:-12px;
      width:32px; height:32px; border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:16px;
    }
    .saved { background:green }
    .down  { background:red   }
    .status-label { margin-left:32px; font-weight:bold; }

    /* MTTR */
    .mttr-card { position:relative; padding-top:28px; }
    .mttr-header {
      position:absolute; top:14px; left:50%;
      transform:translateX(-50%);
      background:#fff; color:#109618;
      padding:4px 12px; font-size:14px;
      border:1px solid #bbb; border-radius:4px;
      font-weight:bold;
      white-space: nowrap;
      text-align: center;
    }
    .mttr-main {
      border:1px solid #bbb; border-radius:6px;
      padding:20px; text-align:center; min-height:105px;
      display:flex; flex-direction:column; justify-content:center;
      background:rgba(255, 255, 255, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .mttr-main-value {
      font-size:36px; font-weight:300; margin-top:8px;
    }
    .mttr-breakdown {
      display:grid; grid-template-columns:1fr 1fr;
      grid-template-rows:1fr 1fr; gap:12px; margin-top:16px;
    }
    .mttr-box {
      border:1px solid #bbb; border-radius:6px;
      padding:24px 8px 8px; position:relative;
      background:rgba(255, 255, 255, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .mttr-box .icon { position:absolute; top:-12px; left:8px; }
    .sub-value { text-align:center; font-size:24px; font-weight:300; margin-top:8px; }
    .sub-label { text-align:center; font-size:14px; margin-top:4px; }
    .mttr-box.emergency .sub-label { color:red }
    .mttr-box.critical  .sub-label { color:orange }
    .mttr-box.major     .sub-label { color:gold }
    .mttr-box.minor     .sub-label { color:blue }

    /* CANVAS */
    canvas { width:100% !important; height:100% !important; }
  </style>
</head>
<body>
  <h1>
    <img src="https://tarek-mahran.github.io/shabakkat/Shabakkat_Logo.png" alt="Shabakkat Logo" class="logo-left">
    <span>Haj PCMs Overview</span>
    <img src="https://tarek-mahran.github.io/shabakkat/HAJ_Dashboard_logo.png" alt="Hajj 1446 Logo" class="logo">
    <button class="toggle-btn" id="toggle-controls">
      <div class="arrow-down"></div>
    </button>
  </h1>

  <div id="controls">
    <input type="file" id="file-input" accept=".xlsx">
    <div class="date-filter-container">
      <label>Time Filter:</label>
      <input type="text" id="date-from" step="60" placeholder="YYYY-MM-DD HH:MM">
      <span>to</span>
      <input type="text" id="date-to" step="60" placeholder="YYYY-MM-DD HH:MM">
      <button id="clear-dates">Clear</button>
    </div>
    <select id="region-filter">
      <option value="">All Regions</option>
    </select>
    <select id="subproject-filter">
      <option value="">All Sub Projects</option>
    </select>
    <button id="export-btn">Export to PDF</button>
    <button id="auto-mode-btn">Auto Mode: OFF</button>
    <select id="refresh-interval" disabled>
      <option value="30">30 seconds</option>
      <option value="60">1 minute</option>
      <option value="300" selected>5 minutes</option>
      <option value="600">10 minutes</option>
      <option value="900">15 minutes</option>
      <option value="1800">30 minutes</option>
      <option value="2700">45 minutes</option>
      <option value="3600">1 hour</option>
      <option value="7200">2 hours</option>
      <option value="10800">3 hours</option>
      <option value="14400">4 hours</option>
      <option value="18000">5 hours</option>
      <option value="21600">6 hours</option>
      <option value="25200">7 hours</option>
      <option value="28800">8 hours</option>
      <option value="32400">9 hours</option>
      <option value="36000">10 hours</option>
      <option value="39600">11 hours</option>
      <option value="43200">12 hours</option>
      <option value="46800">13 hours</option>
      <option value="50400">14 hours</option>
      <option value="54000">15 hours</option>
      <option value="57600">16 hours</option>
      <option value="61200">17 hours</option>
      <option value="64800">18 hours</option>
      <option value="68400">19 hours</option>
      <option value="72000">20 hours</option>
      <option value="75600">21 hours</option>
      <option value="79200">22 hours</option>
      <option value="82800">23 hours</option>
      <option value="86400">24 hours</option>
    </select>
  </div>

  <div class="dashboard">
    <!-- PCM Analysis -->
    <div class="card">
      <h2>PCM Analysis</h2>
      <div>Total Received PCMs</div>
      <div class="metric-box">
        <div id="pcm-total" class="big-number">–</div>
      </div>
      <div>Distributed by Fault Level</div>
      <div class="fault-grid">
        <div class="fault-box emergency">
          <span class="fault-icon">🔔</span>
          <div id="fault-emergency" class="fault-value">–</div>
          <div class="fault-label">Emergency</div>
        </div>
        <div class="fault-box critical">
          <span class="fault-icon">🔔</span>
          <div id="fault-critical" class="fault-value">–</div>
          <div class="fault-label">Critical</div>
        </div>
        <div class="fault-box major">
          <span class="fault-icon">🔔</span>
          <div id="fault-major" class="fault-value">–</div>
          <div class="fault-label">Major</div>
        </div>
        <div class="fault-box minor">
          <span class="fault-icon">🔔</span>
          <div id="fault-minor" class="fault-value">–</div>
          <div class="fault-label">Minor</div>
        </div>
      </div>
      <div>Distributed by PCM Status</div>
      <div class="sub-box" style="height:180px;">
        <canvas id="pcm-status-chart"></canvas>
      </div>
    </div>

    <!-- Outage Analysis -->
    <div class="card">
      <h2>Outage Analysis</h2>
      <div>Total outage PCMs</div>
      <div class="metric-box">
        <div id="outage-total" class="big-number">–</div>
        <div id="outage-unique-sites" class="badge">–</div>
      </div>
      <div>Distributed by TT Type</div>
      <div class="sub-box" style="height:90px;">
        <canvas id="outage-tt-chart"></canvas>
      </div>
      <div>Top Sub Causes</div>
      <div class="sub-box" style="height:283px;">
        <canvas id="outage-subcause-chart"></canvas>
      </div>
    </div>

    <!-- Power & MTTR Analysis -->
    <div class="card">
      <h2>Power & MTTR Analysis</h2>
      <div>Total Power PCMs</div>
      <div class="metric-box">
        <div id="power-total" class="big-number">–</div>
        <div id="power-unique-sites" class="badge">–</div>
      </div>
      <div class="sub-metrics">
        <div class="status-box">
          <div class="status-icon saved">✔</div>
          <div class="status-label" style="color:green">Saved</div>
          <div id="power-saved" class="big-number" style="color:green">–</div>
          <div id="power-saved-sites" class="badge">–</div>
        </div>
        <div class="status-box">
          <div class="status-icon down">✖</div>
          <div class="status-label" style="color:red">Down</div>
          <div id="power-down" class="big-number" style="color:red">–</div>
          <div id="power-down-sites" class="badge">–</div>
        </div>
      </div>
      <div class="mttr-card">
        <div class="mttr-header">Avg. MTTR for All PCMs</div>
        <div class="mttr-main">
          <div id="avg-mttr" class="mttr-main-value">–</div>
        </div>
        <div class="mttr-breakdown">
          <div class="mttr-box emergency">
            <span class="icon">🔔</span>
            <div id="mttr-em" class="sub-value">--</div>
            <div class="sub-label">Emergency</div>
          </div>
          <div class="mttr-box critical">
            <span class="icon">🔔</span>
            <div id="mttr-cr" class="sub-value">--</div>
            <div class="sub-label">Critical</div>
          </div>
          <div class="mttr-box major">
            <span class="icon">🔔</span>
            <div id="mttr-ma" class="sub-value">--</div>
            <div class="sub-label">Major</div>
          </div>
          <div class="mttr-box minor">
            <span class="icon">🔔</span>
            <div id="mttr-mi" class="sub-value">--</div>
            <div class="sub-label">Minor</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Repetition Analysis -->
    <div class="card">
      <h2>Repetition Analysis</h2>
      <div>Repeated outage cases</div>
      <div class="metric-box">
        <div class="repetition-icon">🔴</div>
        <div id="repeated-outage-cases" class="big-number">–</div>
      </div>
      <div>Top repeated outage</div>
      <div class="metric-box">
        <div class="repetition-icon">🔔</div>
        <div id="top-repeated-outage" class="big-number" style="font-size:24px;">–</div>
        <div id="top-repeated-outage-count" class="badge">–</div>
      </div>
      <div>Highest Duration</div>
      <div class="metric-box">
        <div class="repetition-icon">⏰</div>
        <div id="highest-duration" class="big-number" style="font-size:28px;">–</div>
        <div id="highest-duration-site" class="badge">–</div>
      </div>
      <div>Top repeated Alarm</div>
      <div class="metric-box">
        <div class="repetition-icon">⚠️</div>
        <div id="top-repeated-alarm" class="big-number" style="font-size:16px;">–</div>
        <div id="top-repeated-alarm-count" class="badge">–</div>
      </div>
    </div>
  </div>

  <script>
    // GLOBAL CHART.JS CONFIG
    Chart.register(ChartDataLabels);
    Chart.defaults.font.family        = "Arial";
    Chart.defaults.color              = "#444";
    Chart.defaults.plugins.legend.labels.usePointStyle = true;
    Chart.defaults.plugins.tooltip.backgroundColor     = "rgba(0,0,0,0.7)";
    Chart.defaults.scale.grid.display                = false;

    // Global variable to store chart instances for proper cleanup
    let chartInstances = {};
    let autoModeInterval = null;
    let isAutoMode = false;
    let originalData = []; // Store unfiltered data
    const AUTO_URL = "https://tarek-mahran.github.io/shabakkat/PCMS.xlsx";

    // Wait for DOM to be fully loaded before adding event listeners
    document.addEventListener('DOMContentLoaded', function() {
      // Load initial data from URL in background (non-blocking)
      setTimeout(() => {
        initializeDashboard();
      }, 100); // Small delay to ensure page renders first
      
      // Toggle controls visibility
      document.getElementById("toggle-controls").addEventListener("click", function() {
        const controls = document.getElementById("controls");
        const toggleBtn = document.getElementById("toggle-controls");
        
        if (controls.style.display === "none" || controls.style.display === "") {
          controls.style.display = "block";
          toggleBtn.classList.add("rotated");
        } else {
          controls.style.display = "none";
          toggleBtn.classList.remove("rotated");
        }
      });

      // Auto Mode functionality
      document.getElementById("auto-mode-btn").addEventListener("click", function() {
        const btn = this;
        const intervalSelect = document.getElementById("refresh-interval");
        const fileInput = document.getElementById("file-input");
        
        if (!isAutoMode) {
          // Enable Auto Mode
          isAutoMode = true;
          btn.textContent = "Auto Mode: ON";
          btn.classList.add("active");
          intervalSelect.disabled = false;
          fileInput.disabled = true;
          
          // Load data immediately
          loadDataFromURL(true); // Pass true to indicate Auto Mode loading
          
          // Set up interval
          const intervalSeconds = parseInt(intervalSelect.value);
          autoModeInterval = setInterval(() => loadDataFromURL(true), intervalSeconds * 1000);
          
        } else {
          // Disable Auto Mode
          isAutoMode = false;
          btn.textContent = "Auto Mode: OFF";
          btn.classList.remove("active");
          intervalSelect.disabled = true;
          fileInput.disabled = false;
          
          // Clear interval
          if (autoModeInterval) {
            clearInterval(autoModeInterval);
            autoModeInterval = null;
          }
        }
      });

      // Filter event listeners
      document.getElementById("date-from").addEventListener("change", applyFilters);
      document.getElementById("date-to").addEventListener("change", applyFilters);
      document.getElementById("clear-dates").addEventListener("click", clearDateFilter);
      
      // Setup time picker behavior
      setupDateTimePickers();
      
      document.getElementById("region-filter").addEventListener("change", applyFilters);
      document.getElementById("subproject-filter").addEventListener("change", applyFilters);
      // Initialize Flatpickr on date filter inputs
      flatpickr("#date-from", {
        enableTime: true,
        time_24hr: true,
        dateFormat: "Y-m-d H:i",
        defaultHour: 0,
        defaultMinute: 0,
        onChange: applyFilters
      });
      flatpickr("#date-to", {
        enableTime: true,
        time_24hr: true,
        dateFormat: "Y-m-d H:i",
        defaultHour: 23,
        defaultMinute: 59,
        onChange: applyFilters
      });

      // Update interval when changed
      document.getElementById("refresh-interval").addEventListener("change", function() {
        if (isAutoMode && autoModeInterval) {
          clearInterval(autoModeInterval);
          const intervalSeconds = parseInt(this.value);
          autoModeInterval = setInterval(() => loadDataFromURL(true), intervalSeconds * 1000);
        }
      });
    });

    // Initialize dashboard with data on startup (non-blocking)
    async function initializeDashboard() {
      try {
        // Show loading indicator
        showLoadingIndicator(false);
        console.log("Loading dashboard data in background...");
        
        // Load data without blocking UI
        await loadDataFromURL(false);
        
      } catch (error) {
        console.error("Error initializing dashboard:", error);
        console.log("Dashboard initialized with empty data - user can upload file manually");
      } finally {
        // Hide loading indicator
        hideLoadingIndicator();
      }
    }

    // Show loading indicator
    function showLoadingIndicator(isAutoMode = false) {
      const dashboard = document.querySelector('.dashboard');
      if (dashboard && !document.getElementById('loading-indicator')) {
        const loader = document.createElement('div');
        loader.id = 'loading-indicator';
        
        // Different styling for Auto Mode - less intrusive
        const autoModeStyle = isAutoMode ? `
          position: fixed;
          top: 20px;
          right: 20px;
          background: rgba(16, 150, 24, 0.9);
          color: white;
          padding: 8px 16px;
          border-radius: 20px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
          z-index: 1000;
          font-size: 12px;
          display: flex;
          align-items: center;
          gap: 8px;
        ` : `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(255, 255, 255, 0.9);
          padding: 20px 30px;
          border-radius: 8px;
          box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
          z-index: 1000;
          text-align: center;
        `;
        
        const spinnerSize = isAutoMode ? '16px' : '40px';
        const spinnerBorder = isAutoMode ? '2px' : '3px';
        const spinnerColor = isAutoMode ? '#fff' : '#109618';
        const spinnerBg = isAutoMode ? 'rgba(255,255,255,0.3)' : '#f3f3f3';
        
        loader.innerHTML = `
          <div style="${autoModeStyle}">
            ${!isAutoMode ? '<div style="margin-bottom: 10px;">Loading PCMS Data...</div>' : ''}
            <div style="
              width: ${spinnerSize};
              height: ${spinnerSize};
              border: ${spinnerBorder} solid ${spinnerBg};
              border-top: ${spinnerBorder} solid ${spinnerColor};
              border-radius: 50%;
              animation: spin 1s linear infinite;
              ${!isAutoMode ? 'margin: 0 auto;' : ''}
            "></div>
            ${isAutoMode ? '<span>Auto Refreshing...</span>' : ''}
          </div>
        `;
        document.body.appendChild(loader);
        
        // Add spinner animation if not exists
        if (!document.getElementById('spinner-style')) {
          const style = document.createElement('style');
          style.id = 'spinner-style';
          style.textContent = `
            @keyframes spin {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }
          `;
          document.head.appendChild(style);
        }
      }
    }

    // Hide loading indicator
    function hideLoadingIndicator() {
      const loader = document.getElementById('loading-indicator');
      if (loader) {
        loader.remove();
      }
    }

    // Function to load data from URL (non-blocking)
    async function loadDataFromURL(isAutoModeRefresh = false) {
      try {
        await mappingLoaded;
        
        // Show appropriate loading indicator
        showLoadingIndicator(isAutoModeRefresh);
        
        console.log(isAutoModeRefresh ? "Auto Mode: Refreshing data..." : "Fetching data from URL...");
        
        // Use fetch with timeout to prevent hanging
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
        
        const response = await fetch(AUTO_URL, { 
          signal: controller.signal,
          cache: 'no-cache' // Ensure fresh data
        });
        clearTimeout(timeoutId);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        console.log("Processing data...");
        const arrayBuffer = await response.arrayBuffer();
        
        // Process data in next tick to keep UI responsive
        await new Promise(resolve => {
          setTimeout(() => {
            try {
              const wb = XLSX.read(arrayBuffer, {type: "array"});
              const ws = wb.Sheets[wb.SheetNames[0]];
              const raw = XLSX.utils.sheet_to_json(ws, {defval: ""});
              const data = raw.filter(r =>
                hajjSiteIDs.has(String(r["Site Name"]).trim())
              );
              
              // Store original data and populate filters
              originalData = data;
              populateFilters(data);
              
              console.log(isAutoModeRefresh ? "Auto refresh completed:" : "Data processed successfully:", data.length, "records");
              
              // Render dashboard in next tick for smooth UI
              requestAnimationFrame(() => {
                clearDashboard();
                renderDashboard(data);
                console.log("Dashboard updated at:", new Date().toLocaleTimeString());
                
                // Hide loading indicator after rendering
                setTimeout(() => hideLoadingIndicator(), 500);
              });
              
              resolve();
            } catch (error) {
              console.error("Error processing data:", error);
              hideLoadingIndicator();
              resolve(); // Don't block on processing errors
            }
          }, 0);
        });
        
      } catch (error) {
        hideLoadingIndicator();
        
        if (error.name === 'AbortError') {
          console.error("Data loading timed out");
        } else {
          console.error("Error loading data from URL:", error);
        }
        
        // Don't show alert in auto mode to avoid interrupting user
        if (isAutoMode || isAutoModeRefresh) {
          console.log("Will retry on next interval...");
        } else {
          console.log("Failed to load data - user can upload file manually");
        }
        throw error; // Re-throw for initialization error handling
      }
    }

    // Populate filter dropdowns with unique values from data
    function populateFilters(data) {
      // Get unique regions
      const regions = [...new Set(data.map(row => String(row["Region"] || "").trim()).filter(Boolean))].sort();
      const regionSelect = document.getElementById("region-filter");
      regionSelect.innerHTML = '<option value="">All Regions</option>';
      regions.forEach(region => {
        const option = document.createElement("option");
        option.value = region;
        option.textContent = region;
        regionSelect.appendChild(option);
      });

      // Get unique sub projects
      const subProjects = [...new Set(data.map(row => String(row["Sub Project"] || "").trim()).filter(Boolean))].sort();
      const subProjectSelect = document.getElementById("subproject-filter");
      subProjectSelect.innerHTML = '<option value="">All Sub Projects</option>';
      subProjects.forEach(subProject => {
        const option = document.createElement("option");
        option.value = subProject;
        option.textContent = subProject;
        subProjectSelect.appendChild(option);
      });
    }

    // Setup datetime picker behavior
    function setupDateTimePickers() {
      const dateFromInput = document.getElementById("date-from");
      const dateToInput = document.getElementById("date-to");
      
      // Helper function to format datetime for input (YYYY-MM-DDTHH:MM)
      function formatDateTimeLocal(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${year}-${month}-${day}T${hours}:${minutes}`;
      }
      
      // When date-from is clicked without a value, set time to 00:00
      dateFromInput.addEventListener("focus", function() {
        if (!this.value) {
          const today = new Date();
          today.setHours(0, 0, 0, 0); // Set to 00:00
          this.value = formatDateTimeLocal(today);
        }
      });
      
      // When date-to is clicked without a value, set time to 23:59
      dateToInput.addEventListener("focus", function() {
        if (!this.value) {
          const today = new Date();
          today.setHours(23, 59, 0, 0); // Set to 23:59
          this.value = formatDateTimeLocal(today);
        }
      });
      
      // Add input event listeners to show format helper
      [dateFromInput, dateToInput].forEach(input => {
        input.addEventListener("input", function() {
          // Optional: Add visual feedback for valid format
          if (this.value) {
            this.style.color = "#333";
          }
        });
      });
    }

    
    // Helper function to format date/time for display (YYYY-MM-DD HH:MM)
    function formatDateTimeDisplay(dateStr) {
      const date = new Date(dateStr);
      if (isNaN(date.getTime())) return dateStr;
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      return `${year}-${month}-${day} ${hours}:${minutes}`;
    }

    // Clear date filter

    function clearDateFilter() {
      document.getElementById("date-from").value = "";
      document.getElementById("date-to").value = "";
      applyFilters();
    }

    // Apply filters and update dashboard
    function applyFilters() {
      const dateFrom = document.getElementById("date-from").value;
      const dateTo = document.getElementById("date-to").value;
      const regionFilter = document.getElementById("region-filter").value;
      const subProjectFilter = document.getElementById("subproject-filter").value;
      
      let filteredData = originalData;
      
      // Apply date filter
      if (dateFrom || dateTo) {
        filteredData = filteredData.filter(row => {
          const createdAt = row["Created At"];
          if (!createdAt) return false;
          
          // Parse the date - handle various date formats
          let rowDate;
          try {
            // If it's already a Date object
            if (createdAt instanceof Date) {
              rowDate = createdAt;
            } 
            // If it's a string, try to parse it
            else if (typeof createdAt === 'string') {
              // Handle various date formats that might come from Excel
              rowDate = new Date(createdAt);
            }
            // If it's a number (Excel serial date)
            else if (typeof createdAt === 'number') {
              // Excel date serial number conversion
              rowDate = new Date((createdAt - 25569) * 86400 * 1000);
            }
            else {
              return false;
            }
            
            // Check if date is valid
            if (isNaN(rowDate.getTime())) {
              return false;
            }
            
            // Apply date range filter
            if (dateFrom) {
              const fromDate = new Date(dateFrom);
              if (rowDate < fromDate) return false;
            }
            
            if (dateTo) {
              const toDate = new Date(dateTo);
              if (rowDate > toDate) return false;
            }
            
            return true;
          } catch (error) {
            console.warn("Error parsing date:", createdAt, error);
            return false;
          }
        });
      }
      
      // Apply region filter
      if (regionFilter) {
        filteredData = filteredData.filter(row => 
          String(row["Region"] || "").trim() === regionFilter
        );
      }
      
      // Apply sub project filter
      if (subProjectFilter) {
        filteredData = filteredData.filter(row => 
          String(row["Sub Project"] || "").trim() === subProjectFilter
        );
      }
      
      // Log filter details with formatted dates
      let dateRangeText = 'Any';
      if (dateFrom || dateTo) {
        const fromText = dateFrom ? formatDateTimeDisplay(dateFrom) : 'Beginning';
        const toText = dateTo ? formatDateTimeDisplay(dateTo) : 'End';
        dateRangeText = `${fromText} to ${toText}`;
      }
      
      console.log(`Filtered data: ${filteredData.length} records (Time: ${dateRangeText}, Region: ${regionFilter || 'All'}, Sub Project: ${subProjectFilter || 'All'})`);
      
      // Update dashboard with filtered data
      clearDashboard();
      renderDashboard(filteredData);
    }

    // LOAD HAJJ SITE MAPPING
    const MAPPING_URL =
      "https://tarek-mahran.github.io/shabakkat/List%20of%20HAJJ%201446%20sites.xlsx";
    let hajjSiteIDs = new Set();
    const mappingLoaded = (async()=>{
      const resp = await fetch(MAPPING_URL);
      const buf  = await resp.arrayBuffer();
      const wb   = XLSX.read(buf,{type:"array"});
      const ws   = wb.Sheets[wb.SheetNames[0]];
      XLSX.utils.sheet_to_json(ws,{defval:""})
           .forEach(r=> r["Site ID"] && hajjSiteIDs.add(
             String(r["Site ID"]).trim()
           ));
    })();

    // Clear all dashboard data
    function clearDashboard() {
      // Clear all numeric displays
      document.getElementById("pcm-total").innerText = "–";
      document.getElementById("fault-emergency").innerText = "–";
      document.getElementById("fault-critical").innerText = "–";
      document.getElementById("fault-major").innerText = "–";
      document.getElementById("fault-minor").innerText = "–";
      
      document.getElementById("outage-total").innerText = "–";
      document.getElementById("outage-unique-sites").innerText = "–";
      
      document.getElementById("power-total").innerText = "–";
      document.getElementById("power-unique-sites").innerText = "–";
      document.getElementById("power-saved").innerText = "–";
      document.getElementById("power-down").innerText = "–";
      document.getElementById("power-saved-sites").innerText = "–";
      document.getElementById("power-down-sites").innerText = "–";
      
      document.getElementById("avg-mttr").innerText = "–";
      document.getElementById("mttr-em").innerText = "--";
      document.getElementById("mttr-cr").innerText = "--";
      document.getElementById("mttr-ma").innerText = "--";
      document.getElementById("mttr-mi").innerText = "--";

      // Clear repetition analysis
      document.getElementById("repeated-outage-cases").innerText = "–";
      document.getElementById("top-repeated-outage").innerText = "–";
      document.getElementById("top-repeated-outage-count").innerText = "–";
      document.getElementById("highest-duration").innerText = "–";
      document.getElementById("highest-duration-site").innerText = "–";
      document.getElementById("top-repeated-alarm").innerText = "–";
      document.getElementById("top-repeated-alarm-count").innerText = "–";

      // Destroy existing charts
      Object.values(chartInstances).forEach(chart => {
        if (chart && typeof chart.destroy === 'function') {
          chart.destroy();
        }
      });
      chartInstances = {};
    }

    document.getElementById("file-input")
      .addEventListener("change", async e=>{
        // Only process manual file input if auto mode is off
        if (isAutoMode) return;
        
        await mappingLoaded;
        const file = e.target.files[0];
        if (!file) return;
        
        // Show loading indicator for manual uploads
        showLoadingIndicator(false);
        
        // Clear existing dashboard data
        clearDashboard();
        
        const rdr = new FileReader();
        rdr.onload = ev=>{
          // Process file in next tick to keep UI responsive
          setTimeout(() => {
            try {
              const wb  = XLSX.read(ev.target.result,{type:"binary"});
              const ws  = wb.Sheets[wb.SheetNames[0]];
              const raw = XLSX.utils.sheet_to_json(ws,{defval:""});
              const data = raw.filter(r=>
                hajjSiteIDs.has(String(r["Site Name"]).trim())
              );
              
              // Store original data and populate filters
              originalData = data;
              populateFilters(data);
              
              console.log("Manual file loaded:", data.length, "records");
              
              // Render dashboard in next frame for smooth UI
              requestAnimationFrame(() => {
                renderDashboard(data);
                hideLoadingIndicator();
              });
              
            } catch (error) {
              console.error("Error processing file:", error);
              alert("Error processing file. Please check the file format.");
              hideLoadingIndicator();
            }
          }, 0);
        };
        rdr.readAsBinaryString(file);
      });

    // EXPORT TO PDF
    document.getElementById("export-btn")
      .addEventListener("click", async ()=>{
        // Hide elements that shouldn't be in PDF
        const toggleBtn = document.getElementById("toggle-controls");
        const controls = document.getElementById("controls");
        const originalToggleDisplay = toggleBtn.style.display;
        const originalControlsDisplay = controls.style.display;
        
        // Temporarily hide toggle button and controls
        toggleBtn.style.display = "none";
        controls.style.display = "none";
        
        try {
          // Capture the entire page content
          const canvas = await html2canvas(document.body, {
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: null,
            scrollX: 0,
            scrollY: 0,
            width: window.innerWidth,
            height: document.body.scrollHeight
          });
          
          const img = canvas.toDataURL("image/png");
          const { jsPDF } = window.jspdf;
          
          // Calculate PDF dimensions based on canvas
          const imgWidth = canvas.width;
          const imgHeight = canvas.height;
          const ratio = imgWidth / imgHeight;
          
          // Use A4 landscape or adjust based on content
          let pdfWidth, pdfHeight;
          if (ratio > 1.4) { // Wide content - use landscape
            pdfWidth = Math.min(imgWidth * 0.75, 1200);
            pdfHeight = pdfWidth / ratio;
          } else { // Tall content - use portrait or custom size
            pdfHeight = Math.min(imgHeight * 0.75, 1600);
            pdfWidth = pdfHeight * ratio;
          }
          
          const pdf = new jsPDF({
            orientation: ratio > 1.4 ? "landscape" : "portrait",
            unit: "pt",
            format: [pdfWidth, pdfHeight]
          });
          
          pdf.addImage(img, "PNG", 0, 0, pdfWidth, pdfHeight);
          pdf.save("haj-pcms-overview.pdf");
          
        } catch (error) {
          console.error("Error generating PDF:", error);
          alert("Error generating PDF. Please try again.");
        } finally {
          // Restore original visibility
          toggleBtn.style.display = originalToggleDisplay;
          controls.style.display = originalControlsDisplay;
        }
      });

    function formatTime(sec){
      const s = Math.round(sec),
            h = Math.floor(s/3600),
            m = Math.floor((s%3600)/60),
            r = s%60;
      return [h,m,r].map(v=>String(v).padStart(2,"0")).join(":");
    }

    function renderDashboard(data){
      console.log("Rendering dashboard with", data.length, "records");
      pcmAnalysis(data);
      outageAnalysis(data);
      powerMTTRAnalysis(data);
      repetitionAnalysis(data);
    }

    // REPETITION ANALYSIS
    function repetitionAnalysis(data){
      console.log("=== Repetition Analysis ===");

      // 1. REPEATED OUTAGE CASES
      // Filter outage PCMs
      const outagePCMs = data.filter(r=>{
        const ds = String(r["Down Sites"] || "").toLowerCase();
        return ds.includes("site down") || ds.includes("sites down");
      });

      // Remove duplicate TT IDs and count sites with repeated outages
      const uniqueTTIDs = new Set();
      const validOutages = [];
      outagePCMs.forEach(r => {
        const ttId = r["TT ID"];
        if (ttId && !uniqueTTIDs.has(ttId)) {
          uniqueTTIDs.add(ttId);
          validOutages.push(r);
        }
      });

      // Count outages per site
      const siteOutageCounts = {};
      validOutages.forEach(r => {
        const siteName = r["Site Name"];
        if (siteName) {
          siteOutageCounts[siteName] = (siteOutageCounts[siteName] || 0) + 1;
        }
      });

      // Count sites with repeated outages (more than 1)
      const repeatedOutageSites = Object.values(siteOutageCounts).filter(count => count > 1).length;
      document.getElementById("repeated-outage-cases").innerText = repeatedOutageSites;

      // 2. TOP REPEATED OUTAGE
      let topSite = "–";
      let topCount = 0;
      Object.entries(siteOutageCounts).forEach(([site, count]) => {
        if (count > topCount) {
          topCount = count;
          topSite = site;
        }
      });
      document.getElementById("top-repeated-outage").innerText = topSite || "–";
      document.getElementById("top-repeated-outage-count").innerText = topCount > 1 ? topCount : "–";

      // 3. HIGHEST DURATION
      let highestDuration = 0;
      let highestDurationSite = "–";
      let highestDurationFormatted = "–";

      outagePCMs.forEach(r => {
        const createdAt = new Date(r["Created At"] || "");
        const recoveryTime = new Date(r["Fault Recovery Time"] || "");
        
        if (!isNaN(createdAt.getTime()) && !isNaN(recoveryTime.getTime())) {
          const durationMs = recoveryTime.getTime() - createdAt.getTime();
          if (durationMs > 0 && durationMs > highestDuration) {
            highestDuration = durationMs;
            highestDurationSite = r["Site Name"] || "–";
            highestDurationFormatted = formatTime(Math.round(durationMs / 1000));
          }
        }
      });

      document.getElementById("highest-duration").innerText = highestDurationFormatted;
      document.getElementById("highest-duration-site").innerText = highestDurationSite;

      // 4. TOP REPEATED ALARM
      // Filter power PCMs using the same logic as power analysis
      const keys = ["1607","7402","65163","1550","65109","65038",
                    "65106","65338","65037","7103","7409"];
      const powerPCMs1 = data.filter(r => {
        const id = String(r["Alarm ID"] || "").toLowerCase();
        return keys.some(k => id.includes(k)) || 
               id.includes("main") || 
               id.includes("commercial");
      });

      const powerPCMs = powerPCMs1.filter(r => {
        const nm = String(r["Alarm Name"] || "").toLowerCase();
        const ok = ["com","c. p"].some(t => nm.includes(t)) ||
                   nm.startsWith("dc main") ||
                   nm.includes("mains") ||
                   nm.includes("main failure") ||
                   nm.includes("main power") ||
                   nm.startsWith("dc power");
        return ok && !nm.includes("ac");
      });

      // Count alarm occurrences per site
      const alarmSiteCounts = {};
      powerPCMs.forEach(r => {
        const alarmName = r["Alarm Name"];
        const siteName = r["Site Name"];
        if (alarmName && siteName) {
          const key = `${alarmName}@${siteName}`;
          alarmSiteCounts[key] = (alarmSiteCounts[key] || 0) + 1;
        }
      });

      // Find top repeated alarm
      let topAlarm = "–";
      let topAlarmCount = 0;
      Object.entries(alarmSiteCounts).forEach(([key, count]) => {
        if (count > 1 && count > topAlarmCount) {
          topAlarmCount = count;
          const [alarmName, siteName] = key.split('@');
          topAlarm = `${alarmName} @ ${siteName}`;
        }
      });

      document.getElementById("top-repeated-alarm").innerText = topAlarm || "–";
      document.getElementById("top-repeated-alarm-count").innerText = topAlarmCount > 1 ? topAlarmCount : "–";

      console.log("Repetition Analysis Results:", {
        repeatedOutageSites,
        topRepeatedOutage: { site: topSite, count: topCount },
        highestDuration: { duration: highestDurationFormatted, site: highestDurationSite },
        topRepeatedAlarm: { alarm: topAlarm, count: topAlarmCount }
      });
    }

    // PCM ANALYSIS
    function pcmAnalysis(data){
      console.log("=== PCM Analysis ===");
      console.log("Processing", data.length, "records");
      
      document.getElementById("pcm-total").innerText = data.length;
      const faults={Emergency:0,Critical:0,Major:0,Minor:0},
            stats ={Running:0,Closed:0,Cancelled:0,Escalated:0};
      data.forEach(r=>{
        if(faults[r["Fault Level"]]!==undefined) faults[r["Fault Level"]]++;
        const st = r["pcm_status"]==="Completed"?"Closed":r["pcm_status"];
        if(stats[st]!==undefined) stats[st]++;
      });
      
      console.log("Fault Level distribution:", faults);
      console.log("Status distribution:", stats);
      
      ["Emergency","Critical","Major","Minor"].forEach(l=>{
        document.getElementById(`fault-${l.toLowerCase()}`).innerText = faults[l];
      });

      // PCM-STATUS CHART with labels on left and right sides (percentage only)
      const totalStatus = Object.values(stats).reduce((a,b)=>a+b,0);
      
      // Destroy existing chart if it exists
      if (chartInstances.pcmStatusChart) {
        chartInstances.pcmStatusChart.destroy();
      }
      
      chartInstances.pcmStatusChart = new Chart(document.getElementById("pcm-status-chart"),{
        type:"doughnut",
        data:{
          labels:Object.keys(stats),
          datasets:[{
            data:Object.values(stats),
            backgroundColor:["#3366cc","#109618","#aaaaaa","#ffbb33"],
            borderWidth:0
          }]
        },
        options:{
          responsive:true, 
          maintainAspectRatio:false,
          cutout:"60%",
          layout: {
            padding: {
              top: 15,
              right: 30,
              bottom: 15,
              left: 30
            }
          },
          plugins:{
            legend:{
              display:true, 
              position:"bottom", 
              align:"center",
              labels:{
                usePointStyle:true,
                boxWidth:6,
                font:{size:8},
                padding:6,
                generateLabels: function(chart) {
                  const data = chart.data;
                  if (data.labels.length && data.datasets.length) {
                    return data.labels.map((label, i) => {
                      const meta = chart.getDatasetMeta(0);
                      const style = meta.controller.getStyle(i);
                      return {
                        text: label,
                        fillStyle: style.backgroundColor,
                        strokeStyle: style.borderColor,
                        lineWidth: style.borderWidth,
                        pointStyle: 'circle',
                        hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                        index: i
                      };
                    });
                  }
                  return [];
                }
              }
            },
            datalabels:{
              display: false // We'll use custom labels instead
            }
          }
        },
        plugins: [{
          // Custom plugin to draw percentage labels on sides with connector lines
          afterDatasetsDraw: function(chart) {
            const ctx = chart.ctx;
            const meta = chart.getDatasetMeta(0);
            const chartArea = chart.chartArea;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            
            // Arrays to store labels for left and right sides
            const leftLabels = [];
            const rightLabels = [];
            
            // Categorize labels by side
            meta.data.forEach((element, index) => {
              const model = element;
              const { startAngle, endAngle } = model;
              const middleAngle = (startAngle + endAngle) / 2;
              
              // Determine which side (left or right)
              const labelData = {
                index: index,
                angle: middleAngle,
                value: chart.data.datasets[0].data[index],
                label: chart.data.labels[index],
                color: chart.data.datasets[0].backgroundColor[index]
              };
              
              if (Math.cos(middleAngle) < 0) {
                leftLabels.push(labelData);
              } else {
                rightLabels.push(labelData);
              }
            });
            
            // Sort labels by vertical position
            leftLabels.sort((a, b) => Math.sin(a.angle) - Math.sin(b.angle));
            rightLabels.sort((a, b) => Math.sin(a.angle) - Math.sin(b.angle));
            
            // Draw left side labels
            const leftX = chartArea.left - 2;
            const leftStartY = centerY - (leftLabels.length * 18) / 2;
            
            leftLabels.forEach((labelData, i) => {
              const element = meta.data[labelData.index];
              const { x, y, innerRadius, outerRadius } = element;
              const middleRadius = (innerRadius + outerRadius) / 2;
              const startX = x + Math.cos(labelData.angle) * middleRadius;
              const startY = y + Math.sin(labelData.angle) * middleRadius;
              const labelY = leftStartY + (i * 18);
              
              // Draw connector line (extremely short)
              ctx.save();
              ctx.strokeStyle = "#999";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(startX, startY);
              ctx.lineTo(leftX, labelY);
              ctx.stroke();
              ctx.restore();
              
              // Draw percentage box only
              const percentage = totalStatus ? (labelData.value/totalStatus*100).toFixed(1) : 0;
              const text = `${percentage}%`;
              
              ctx.save();
              ctx.fillStyle = labelData.color;
              ctx.fillRect(leftX - 18, labelY - 5, 22, 10);
              ctx.fillStyle = "#fff";
              ctx.font = "bold 8px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(text, leftX - 7, labelY);
              ctx.restore();
            });
            
            // Draw right side labels
            const rightX = chartArea.right + 2;
            const rightStartY = centerY - (rightLabels.length * 18) / 2;
            
            rightLabels.forEach((labelData, i) => {
              const element = meta.data[labelData.index];
              const { x, y, innerRadius, outerRadius } = element;
              const middleRadius = (innerRadius + outerRadius) / 2;
              const startX = x + Math.cos(labelData.angle) * middleRadius;
              const startY = y + Math.sin(labelData.angle) * middleRadius;
              const labelY = rightStartY + (i * 18);
              
              // Draw connector line (extremely short)
              ctx.save();
              ctx.strokeStyle = "#999";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(startX, startY);
              ctx.lineTo(rightX, labelY);
              ctx.stroke();
              ctx.restore();
              
              // Draw percentage box only
              const percentage = totalStatus ? (labelData.value/totalStatus*100).toFixed(1) : 0;
              const text = `${percentage}%`;
              
              ctx.save();
              ctx.fillStyle = labelData.color;
              ctx.fillRect(rightX - 4, labelY - 5, 22, 10);
              ctx.fillStyle = "#fff";
              ctx.font = "bold 8px Arial";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(text, rightX + 7, labelY);
              ctx.restore();
            });
          }
        }]
      });
    }

    // OUTAGE ANALYSIS
    function outageAnalysis(data){
      console.log("=== Outage Analysis ===");
      
      const out = data.filter(r=>{
        const ds=String(r["Down Sites"]||"").toLowerCase();
        return ds.includes("site down")||ds.includes("sites down");
      });
      
      console.log("Outage PCMs found:", out.length);
      
      document.getElementById("outage-total").innerText = out.length;
      document.getElementById("outage-unique-sites").innerText =
        new Set(out.map(r=>r["Site Name"])).size;

      let em=0, te=0;
      out.forEach(r=>{
        const s = r["Skill"]==="Telecom"?"TE":r["Skill"];
        if(s==="EM") em++; else if(s==="TE") te++;
      });
      const tot=em+te, pe=tot?em/tot*100:0, pt=tot?te/tot*100:0;
      
      // Destroy existing chart if it exists
      if (chartInstances.outageTTChart) {
        chartInstances.outageTTChart.destroy();
      }
      
      chartInstances.outageTTChart = new Chart(document.getElementById("outage-tt-chart"),{
        type:"bar",
        data:{
          labels:[""],
          datasets:[
            {label:"EM", data:[pe], backgroundColor:"#ffbb33"},
            {label:"TE", data:[pt], backgroundColor:"#3366cc"}
          ]
        },
        options:{
          responsive:true, maintainAspectRatio:false,
          indexAxis:"y",
          scales:{ x:{stacked:true, display:false}, y:{stacked:true, display:false} },
          plugins:{
            legend:{
              display:true, position:"top", align:"end",
              labels:{ usePointStyle:true, boxWidth:8, font:{size:10}, padding:8 }
            },
            datalabels:{
              color:"#fff", anchor:"center", align:"center",
              font:{weight:"bold",size:10},
              formatter:v=>v.toFixed(2)+"%"
            }
          }
        }
      });

      const comp = out.filter(r=>r["pcm_status"]==="Completed"),
            sub  = {};
      comp.forEach(r=> sub[r["Sub Cause"]] = (sub[r["Sub Cause"]]||0)+1 );
      const top5 = Object.entries(sub)
                        .sort((a,b)=>b[1]-a[1])
                        .slice(0,5);
      
      // Calculate total for percentage calculation
      const totalSubCauses = top5.reduce((sum, [, count]) => sum + count, 0);
      
      // Destroy existing chart if it exists
      if (chartInstances.outageSubcauseChart) {
        chartInstances.outageSubcauseChart.destroy();
      }
      
      chartInstances.outageSubcauseChart = new Chart(document.getElementById("outage-subcause-chart"),{
        type:"bar",
        data:{
          labels: top5.map(r=>r[0]),
          datasets:[{
            data: top5.map(r=>r[1]),
            backgroundColor:"#3366cc", barPercentage:0.6,
            categoryPercentage:0.8, borderRadius:4
          }]
        },
        options:{
          indexAxis:"y", responsive:true, maintainAspectRatio:false,
          scales:{
            x:{ display:false, grid:{display:false} },
            y:{ 
              display:true, 
              grid:{display:false}, 
              ticks:{
                font:{size:9}, 
                padding:6,
                textStrokeWidth: 0,
                maxRotation: 0,
                callback: function(value, index, values) {
                  const label = this.getLabelForValue(value);
                  return label.length > 20 ? label.substring(0, 17) + '...' : label;
                }
              },
              position: 'left'
            }
          },
          plugins:{
            legend:{ display:false },
            datalabels:{
              display: true,
              anchor:"end", 
              align:"right", 
              color:"#333",
              font:{weight:"bold", size:9}, 
              formatter:(value, context) => {
                const percentage = totalSubCauses ? ((value / totalSubCauses) * 100).toFixed(1) : 0;
                return `${percentage}%`;
              },
              clip: false
            }
          },
          layout:{ padding:{left:20, right:30, top:8, bottom:8} }
        }
      });
    }

    // POWER & MTTR ANALYSIS
    function powerMTTRAnalysis(data){
      console.log("=== Power & MTTR Analysis ===");
      
      const keys=["1607","7402","65163","1550","65109","65038",
                  "65106","65338","65037","7103","7409"];
      const s1 = data.filter(r=>{
        const id=String(r["Alarm ID"]||"").toLowerCase();
        return keys.some(k=>id.includes(k))
            || id.includes("main")
            || id.includes("commercial");
      });
      const power = s1.filter(r=>{
        const nm=String(r["Alarm Name"]||"").toLowerCase();
        const ok = ["com","c. p"].some(t=>nm.includes(t))
                || nm.startsWith("dc main")
                || nm.includes("mains")
                || nm.includes("main failure")
                || nm.includes("main power")
                || nm.startsWith("dc power");
        return ok && !nm.includes("ac");
      });

      console.log("Power PCMs found:", power.length);

      document.getElementById("power-total").innerText = power.length;
      document.getElementById("power-unique-sites").innerText =
        new Set(power.map(r=>r["Site Name"])).size;

      // Get outage events (PCMs with "sites down" or "site down")
      const outageEvents = data.filter(r=>{
        const ds=String(r["Down Sites"]||"").toLowerCase();
        return ds.includes("site down")||ds.includes("sites down");
      }).map(r => ({
        siteName: r["Site Name"],
        createdAt: new Date(r["Created At"] || ""),
        isValidDate: !isNaN(new Date(r["Created At"] || "").getTime())
      })).filter(e => e.isValidDate);

      // Categorize power PCMs as "Down" or "Saved"
      const downPCMs = [];
      const savedPCMs = [];

      power.forEach(powerPCM => {
        const powerSite = powerPCM["Site Name"];
        const powerTime = new Date(powerPCM["Created At"] || "");
        const isPowerTimeValid = !isNaN(powerTime.getTime());
        
        if (!isPowerTimeValid) {
          savedPCMs.push(powerPCM); // Default to saved if no valid time
          return;
        }

        // Check if there's an outage event for the same site within 24 hours
        const hasOutageWithin24h = outageEvents.some(outage => {
          if (outage.siteName !== powerSite) return false;
          
          const timeDiffMs = Math.abs(powerTime.getTime() - outage.createdAt.getTime());
          const hours24InMs = 24 * 60 * 60 * 1000;
          
          return timeDiffMs <= hours24InMs;
        });

        if (hasOutageWithin24h) {
          downPCMs.push(powerPCM);
        } else {
          savedPCMs.push(powerPCM);
        }
      });

      document.getElementById("power-down").innerText = downPCMs.length;
      document.getElementById("power-saved").innerText = savedPCMs.length;
      
      // Count unique sites for badges
      document.getElementById("power-down-sites").innerText =
        new Set(downPCMs.map(r=>r["Site Name"])).size;
      document.getElementById("power-saved-sites").innerText =
        new Set(savedPCMs.map(r=>r["Site Name"])).size;

      // MTTR Calculation with specific filtering
      const mttrPCMs = data.filter(r => {
        // Filter completed PCMs
        if (r["pcm_status"] !== "Completed") return false;
        
        // Filter FLM resolved owner
        if (r["Resolved Owner"] !== "FLM") return false;
        
        // Ignore HC in TT Type
        const ttType = String(r["TT Type"] || "").toLowerCase();
        if (ttType.includes("hc")) return false;
        
        // Ignore HC in Title
        const title = String(r["Title"] || "").toLowerCase();
        if (title.includes("hc")) return false;
        
        // Ignore Health Check in Alarm Name
        const alarmName = String(r["Alarm Name"] || "").toLowerCase();
        if (alarmName.includes("health check")) return false;
        
        return true;
      });

      // Calculate MTTR using Fault Recovery Time and Created At
      const mttrTimes = [];
      mttrPCMs.forEach(r => {
        const reportedTime = new Date(r["Created At"] || "");
        const resolvedTime = new Date(r["Fault Recovery Time"] || "");
        
        if (!isNaN(reportedTime.getTime()) && !isNaN(resolvedTime.getTime())) {
          const mttrMs = resolvedTime.getTime() - reportedTime.getTime();
          if (mttrMs > 0) { // Only positive values
            mttrTimes.push(Math.round(mttrMs / 1000)); // Convert to seconds
          }
        }
      });

      // Average MTTR for all PCMs
      const avgMTTR = mttrTimes.length ? mttrTimes.reduce((a,b)=>a+b,0) / mttrTimes.length : 0;
      document.getElementById("avg-mttr").innerText =
        mttrTimes.length ? formatTime(avgMTTR) : "--";

      // MTTR by Fault Level
      const byLvl = {};
      mttrPCMs.forEach(r => {
        const l = r["Fault Level"];
        if (!l || !["Emergency", "Critical", "Major", "Minor"].includes(l)) return;
        
        const reportedTime = new Date(r["Created At"] || "");
        const resolvedTime = new Date(r["Fault Recovery Time"] || "");
        
        if (!isNaN(reportedTime.getTime()) && !isNaN(resolvedTime.getTime())) {
          const mttrMs = resolvedTime.getTime() - reportedTime.getTime();
          if (mttrMs > 0) {
            (byLvl[l] = byLvl[l] || []).push(Math.round(mttrMs / 1000));
          }
        }
      });

      ["Emergency","Critical","Major","Minor"].forEach(l=>{
        const arr = byLvl[l] || [];
        const avgTime = arr.length ? arr.reduce((a,b)=>a+b,0) / arr.length : 0;
        document.getElementById({
          Emergency:"mttr-em",
          Critical:"mttr-cr",
          Major:"mttr-ma",
          Minor:"mttr-mi"
        }[l]).innerText = arr.length ? formatTime(avgTime) : "--";
      });
    }
  </script>
</body>
</html>
